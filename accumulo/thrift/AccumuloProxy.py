# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
# Autogenerated by Thrift Compiler (0.17.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def addConstraint(self, sharedSecret, tableName, constraintClassName):
        """
        Parameters:
         - sharedSecret
         - tableName
         - constraintClassName

        """
        pass

    def addSplits(self, sharedSecret, tableName, splits):
        """
        Parameters:
         - sharedSecret
         - tableName
         - splits

        """
        pass

    def attachIterator(self, sharedSecret, tableName, setting, scopes):
        """
        Parameters:
         - sharedSecret
         - tableName
         - setting
         - scopes

        """
        pass

    def checkIteratorConflicts(self, sharedSecret, tableName, setting, scopes):
        """
        Parameters:
         - sharedSecret
         - tableName
         - setting
         - scopes

        """
        pass

    def clearLocatorCache(self, sharedSecret, tableName):
        """
        Parameters:
         - sharedSecret
         - tableName

        """
        pass

    def cloneTable(self, sharedSecret, tableName, newTableName, flush, propertiesToSet, propertiesToExclude):
        """
        Parameters:
         - sharedSecret
         - tableName
         - newTableName
         - flush
         - propertiesToSet
         - propertiesToExclude

        """
        pass

    def compactTable(self, sharedSecret, tableName, startRow, endRow, iterators, flush, wait, selectorConfig, configurerConfig):
        """
        Parameters:
         - sharedSecret
         - tableName
         - startRow
         - endRow
         - iterators
         - flush
         - wait
         - selectorConfig
         - configurerConfig

        """
        pass

    def cancelCompaction(self, sharedSecret, tableName):
        """
        Parameters:
         - sharedSecret
         - tableName

        """
        pass

    def createTable(self, sharedSecret, tableName, versioningIter, type):
        """
        Parameters:
         - sharedSecret
         - tableName
         - versioningIter
         - type

        """
        pass

    def deleteTable(self, sharedSecret, tableName):
        """
        Parameters:
         - sharedSecret
         - tableName

        """
        pass

    def deleteRows(self, sharedSecret, tableName, startRow, endRow):
        """
        Parameters:
         - sharedSecret
         - tableName
         - startRow
         - endRow

        """
        pass

    def exportTable(self, sharedSecret, tableName, exportDir):
        """
        Parameters:
         - sharedSecret
         - tableName
         - exportDir

        """
        pass

    def flushTable(self, sharedSecret, tableName, startRow, endRow, wait):
        """
        Parameters:
         - sharedSecret
         - tableName
         - startRow
         - endRow
         - wait

        """
        pass

    def getDiskUsage(self, sharedSecret, tables):
        """
        Parameters:
         - sharedSecret
         - tables

        """
        pass

    def getLocalityGroups(self, sharedSecret, tableName):
        """
        Parameters:
         - sharedSecret
         - tableName

        """
        pass

    def getIteratorSetting(self, sharedSecret, tableName, iteratorName, scope):
        """
        Parameters:
         - sharedSecret
         - tableName
         - iteratorName
         - scope

        """
        pass

    def getMaxRow(self, sharedSecret, tableName, auths, startRow, startInclusive, endRow, endInclusive):
        """
        Parameters:
         - sharedSecret
         - tableName
         - auths
         - startRow
         - startInclusive
         - endRow
         - endInclusive

        """
        pass

    def getTableProperties(self, sharedSecret, tableName):
        """
        Parameters:
         - sharedSecret
         - tableName

        """
        pass

    def importDirectory(self, sharedSecret, tableName, importDir, failureDir, setTime):
        """
        Parameters:
         - sharedSecret
         - tableName
         - importDir
         - failureDir
         - setTime

        """
        pass

    def importTable(self, sharedSecret, tableName, importDir):
        """
        Parameters:
         - sharedSecret
         - tableName
         - importDir

        """
        pass

    def listSplits(self, sharedSecret, tableName, maxSplits):
        """
        Parameters:
         - sharedSecret
         - tableName
         - maxSplits

        """
        pass

    def listTables(self, sharedSecret):
        """
        Parameters:
         - sharedSecret

        """
        pass

    def listIterators(self, sharedSecret, tableName):
        """
        Parameters:
         - sharedSecret
         - tableName

        """
        pass

    def listConstraints(self, sharedSecret, tableName):
        """
        Parameters:
         - sharedSecret
         - tableName

        """
        pass

    def mergeTablets(self, sharedSecret, tableName, startRow, endRow):
        """
        Parameters:
         - sharedSecret
         - tableName
         - startRow
         - endRow

        """
        pass

    def offlineTable(self, sharedSecret, tableName, wait):
        """
        Parameters:
         - sharedSecret
         - tableName
         - wait

        """
        pass

    def onlineTable(self, sharedSecret, tableName, wait):
        """
        Parameters:
         - sharedSecret
         - tableName
         - wait

        """
        pass

    def removeConstraint(self, sharedSecret, tableName, constraint):
        """
        Parameters:
         - sharedSecret
         - tableName
         - constraint

        """
        pass

    def removeIterator(self, sharedSecret, tableName, iterName, scopes):
        """
        Parameters:
         - sharedSecret
         - tableName
         - iterName
         - scopes

        """
        pass

    def removeTableProperty(self, sharedSecret, tableName, property):
        """
        Parameters:
         - sharedSecret
         - tableName
         - property

        """
        pass

    def renameTable(self, sharedSecret, oldTableName, newTableName):
        """
        Parameters:
         - sharedSecret
         - oldTableName
         - newTableName

        """
        pass

    def setLocalityGroups(self, sharedSecret, tableName, groups):
        """
        Parameters:
         - sharedSecret
         - tableName
         - groups

        """
        pass

    def setTableProperty(self, sharedSecret, tableName, property, value):
        """
        Parameters:
         - sharedSecret
         - tableName
         - property
         - value

        """
        pass

    def splitRangeByTablets(self, sharedSecret, tableName, range, maxSplits):
        """
        Parameters:
         - sharedSecret
         - tableName
         - range
         - maxSplits

        """
        pass

    def tableExists(self, sharedSecret, tableName):
        """
        Parameters:
         - sharedSecret
         - tableName

        """
        pass

    def tableIdMap(self, sharedSecret):
        """
        Parameters:
         - sharedSecret

        """
        pass

    def testTableClassLoad(self, sharedSecret, tableName, className, asTypeName):
        """
        Parameters:
         - sharedSecret
         - tableName
         - className
         - asTypeName

        """
        pass

    def pingTabletServer(self, sharedSecret, tserver):
        """
        Parameters:
         - sharedSecret
         - tserver

        """
        pass

    def getActiveScans(self, sharedSecret, tserver):
        """
        Parameters:
         - sharedSecret
         - tserver

        """
        pass

    def getActiveCompactions(self, sharedSecret, tserver):
        """
        Parameters:
         - sharedSecret
         - tserver

        """
        pass

    def getSiteConfiguration(self, sharedSecret):
        """
        Parameters:
         - sharedSecret

        """
        pass

    def getSystemConfiguration(self, sharedSecret):
        """
        Parameters:
         - sharedSecret

        """
        pass

    def getTabletServers(self, sharedSecret):
        """
        Parameters:
         - sharedSecret

        """
        pass

    def removeProperty(self, sharedSecret, property):
        """
        Parameters:
         - sharedSecret
         - property

        """
        pass

    def setProperty(self, sharedSecret, property, value):
        """
        Parameters:
         - sharedSecret
         - property
         - value

        """
        pass

    def testClassLoad(self, sharedSecret, className, asTypeName):
        """
        Parameters:
         - sharedSecret
         - className
         - asTypeName

        """
        pass

    def authenticateUser(self, sharedSecret, user, properties):
        """
        Parameters:
         - sharedSecret
         - user
         - properties

        """
        pass

    def changeUserAuthorizations(self, sharedSecret, user, authorizations):
        """
        Parameters:
         - sharedSecret
         - user
         - authorizations

        """
        pass

    def changeLocalUserPassword(self, sharedSecret, user, password):
        """
        Parameters:
         - sharedSecret
         - user
         - password

        """
        pass

    def createLocalUser(self, sharedSecret, user, password):
        """
        Parameters:
         - sharedSecret
         - user
         - password

        """
        pass

    def dropLocalUser(self, sharedSecret, user):
        """
        Parameters:
         - sharedSecret
         - user

        """
        pass

    def getUserAuthorizations(self, sharedSecret, user):
        """
        Parameters:
         - sharedSecret
         - user

        """
        pass

    def grantSystemPermission(self, sharedSecret, user, perm):
        """
        Parameters:
         - sharedSecret
         - user
         - perm

        """
        pass

    def grantTablePermission(self, sharedSecret, user, table, perm):
        """
        Parameters:
         - sharedSecret
         - user
         - table
         - perm

        """
        pass

    def hasSystemPermission(self, sharedSecret, user, perm):
        """
        Parameters:
         - sharedSecret
         - user
         - perm

        """
        pass

    def hasTablePermission(self, sharedSecret, user, table, perm):
        """
        Parameters:
         - sharedSecret
         - user
         - table
         - perm

        """
        pass

    def listLocalUsers(self, sharedSecret):
        """
        Parameters:
         - sharedSecret

        """
        pass

    def revokeSystemPermission(self, sharedSecret, user, perm):
        """
        Parameters:
         - sharedSecret
         - user
         - perm

        """
        pass

    def revokeTablePermission(self, sharedSecret, user, table, perm):
        """
        Parameters:
         - sharedSecret
         - user
         - table
         - perm

        """
        pass

    def grantNamespacePermission(self, sharedSecret, user, namespaceName, perm):
        """
        Parameters:
         - sharedSecret
         - user
         - namespaceName
         - perm

        """
        pass

    def hasNamespacePermission(self, sharedSecret, user, namespaceName, perm):
        """
        Parameters:
         - sharedSecret
         - user
         - namespaceName
         - perm

        """
        pass

    def revokeNamespacePermission(self, sharedSecret, user, namespaceName, perm):
        """
        Parameters:
         - sharedSecret
         - user
         - namespaceName
         - perm

        """
        pass

    def createBatchScanner(self, sharedSecret, tableName, options):
        """
        Parameters:
         - sharedSecret
         - tableName
         - options

        """
        pass

    def createScanner(self, sharedSecret, tableName, options):
        """
        Parameters:
         - sharedSecret
         - tableName
         - options

        """
        pass

    def hasNext(self, scanner):
        """
        Parameters:
         - scanner

        """
        pass

    def nextEntry(self, scanner):
        """
        Parameters:
         - scanner

        """
        pass

    def nextK(self, scanner, k):
        """
        Parameters:
         - scanner
         - k

        """
        pass

    def closeScanner(self, scanner):
        """
        Parameters:
         - scanner

        """
        pass

    def updateAndFlush(self, sharedSecret, tableName, cells):
        """
        Parameters:
         - sharedSecret
         - tableName
         - cells

        """
        pass

    def createWriter(self, sharedSecret, tableName, opts):
        """
        Parameters:
         - sharedSecret
         - tableName
         - opts

        """
        pass

    def update(self, writer, cells):
        """
        Parameters:
         - writer
         - cells

        """
        pass

    def flush(self, writer):
        """
        Parameters:
         - writer

        """
        pass

    def closeWriter(self, writer):
        """
        Parameters:
         - writer

        """
        pass

    def updateRowConditionally(self, sharedSecret, tableName, row, updates):
        """
        Parameters:
         - sharedSecret
         - tableName
         - row
         - updates

        """
        pass

    def createConditionalWriter(self, sharedSecret, tableName, options):
        """
        Parameters:
         - sharedSecret
         - tableName
         - options

        """
        pass

    def updateRowsConditionally(self, conditionalWriter, updates):
        """
        Parameters:
         - conditionalWriter
         - updates

        """
        pass

    def closeConditionalWriter(self, conditionalWriter):
        """
        Parameters:
         - conditionalWriter

        """
        pass

    def getRowRange(self, row):
        """
        Parameters:
         - row

        """
        pass

    def getFollowing(self, key, part):
        """
        Parameters:
         - key
         - part

        """
        pass

    def systemNamespace(self):
        pass

    def defaultNamespace(self):
        pass

    def listNamespaces(self, sharedSecret):
        """
        Parameters:
         - sharedSecret

        """
        pass

    def namespaceExists(self, sharedSecret, namespaceName):
        """
        Parameters:
         - sharedSecret
         - namespaceName

        """
        pass

    def createNamespace(self, sharedSecret, namespaceName):
        """
        Parameters:
         - sharedSecret
         - namespaceName

        """
        pass

    def deleteNamespace(self, sharedSecret, namespaceName):
        """
        Parameters:
         - sharedSecret
         - namespaceName

        """
        pass

    def renameNamespace(self, sharedSecret, oldNamespaceName, newNamespaceName):
        """
        Parameters:
         - sharedSecret
         - oldNamespaceName
         - newNamespaceName

        """
        pass

    def setNamespaceProperty(self, sharedSecret, namespaceName, property, value):
        """
        Parameters:
         - sharedSecret
         - namespaceName
         - property
         - value

        """
        pass

    def removeNamespaceProperty(self, sharedSecret, namespaceName, property):
        """
        Parameters:
         - sharedSecret
         - namespaceName
         - property

        """
        pass

    def getNamespaceProperties(self, sharedSecret, namespaceName):
        """
        Parameters:
         - sharedSecret
         - namespaceName

        """
        pass

    def namespaceIdMap(self, sharedSecret):
        """
        Parameters:
         - sharedSecret

        """
        pass

    def attachNamespaceIterator(self, sharedSecret, namespaceName, setting, scopes):
        """
        Parameters:
         - sharedSecret
         - namespaceName
         - setting
         - scopes

        """
        pass

    def removeNamespaceIterator(self, sharedSecret, namespaceName, name, scopes):
        """
        Parameters:
         - sharedSecret
         - namespaceName
         - name
         - scopes

        """
        pass

    def getNamespaceIteratorSetting(self, sharedSecret, namespaceName, name, scope):
        """
        Parameters:
         - sharedSecret
         - namespaceName
         - name
         - scope

        """
        pass

    def listNamespaceIterators(self, sharedSecret, namespaceName):
        """
        Parameters:
         - sharedSecret
         - namespaceName

        """
        pass

    def checkNamespaceIteratorConflicts(self, sharedSecret, namespaceName, setting, scopes):
        """
        Parameters:
         - sharedSecret
         - namespaceName
         - setting
         - scopes

        """
        pass

    def addNamespaceConstraint(self, sharedSecret, namespaceName, constraintClassName):
        """
        Parameters:
         - sharedSecret
         - namespaceName
         - constraintClassName

        """
        pass

    def removeNamespaceConstraint(self, sharedSecret, namespaceName, id):
        """
        Parameters:
         - sharedSecret
         - namespaceName
         - id

        """
        pass

    def listNamespaceConstraints(self, sharedSecret, namespaceName):
        """
        Parameters:
         - sharedSecret
         - namespaceName

        """
        pass

    def testNamespaceClassLoad(self, sharedSecret, namespaceName, className, asTypeName):
        """
        Parameters:
         - sharedSecret
         - namespaceName
         - className
         - asTypeName

        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def addConstraint(self, sharedSecret, tableName, constraintClassName):
        """
        Parameters:
         - sharedSecret
         - tableName
         - constraintClassName

        """
        self.send_addConstraint(sharedSecret, tableName, constraintClassName)
        return self.recv_addConstraint()

    def send_addConstraint(self, sharedSecret, tableName, constraintClassName):
        self._oprot.writeMessageBegin('addConstraint', TMessageType.CALL, self._seqid)
        args = addConstraint_args()
        args.sharedSecret = sharedSecret
        args.tableName = tableName
        args.constraintClassName = constraintClassName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_addConstraint(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = addConstraint_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "addConstraint failed: unknown result")

    def addSplits(self, sharedSecret, tableName, splits):
        """
        Parameters:
         - sharedSecret
         - tableName
         - splits

        """
        self.send_addSplits(sharedSecret, tableName, splits)
        self.recv_addSplits()

    def send_addSplits(self, sharedSecret, tableName, splits):
        self._oprot.writeMessageBegin('addSplits', TMessageType.CALL, self._seqid)
        args = addSplits_args()
        args.sharedSecret = sharedSecret
        args.tableName = tableName
        args.splits = splits
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_addSplits(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = addSplits_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        return

    def attachIterator(self, sharedSecret, tableName, setting, scopes):
        """
        Parameters:
         - sharedSecret
         - tableName
         - setting
         - scopes

        """
        self.send_attachIterator(sharedSecret, tableName, setting, scopes)
        self.recv_attachIterator()

    def send_attachIterator(self, sharedSecret, tableName, setting, scopes):
        self._oprot.writeMessageBegin('attachIterator', TMessageType.CALL, self._seqid)
        args = attachIterator_args()
        args.sharedSecret = sharedSecret
        args.tableName = tableName
        args.setting = setting
        args.scopes = scopes
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_attachIterator(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = attachIterator_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        return

    def checkIteratorConflicts(self, sharedSecret, tableName, setting, scopes):
        """
        Parameters:
         - sharedSecret
         - tableName
         - setting
         - scopes

        """
        self.send_checkIteratorConflicts(sharedSecret, tableName, setting, scopes)
        self.recv_checkIteratorConflicts()

    def send_checkIteratorConflicts(self, sharedSecret, tableName, setting, scopes):
        self._oprot.writeMessageBegin('checkIteratorConflicts', TMessageType.CALL, self._seqid)
        args = checkIteratorConflicts_args()
        args.sharedSecret = sharedSecret
        args.tableName = tableName
        args.setting = setting
        args.scopes = scopes
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_checkIteratorConflicts(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = checkIteratorConflicts_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        return

    def clearLocatorCache(self, sharedSecret, tableName):
        """
        Parameters:
         - sharedSecret
         - tableName

        """
        self.send_clearLocatorCache(sharedSecret, tableName)
        self.recv_clearLocatorCache()

    def send_clearLocatorCache(self, sharedSecret, tableName):
        self._oprot.writeMessageBegin('clearLocatorCache', TMessageType.CALL, self._seqid)
        args = clearLocatorCache_args()
        args.sharedSecret = sharedSecret
        args.tableName = tableName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_clearLocatorCache(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = clearLocatorCache_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        return

    def cloneTable(self, sharedSecret, tableName, newTableName, flush, propertiesToSet, propertiesToExclude):
        """
        Parameters:
         - sharedSecret
         - tableName
         - newTableName
         - flush
         - propertiesToSet
         - propertiesToExclude

        """
        self.send_cloneTable(sharedSecret, tableName, newTableName, flush, propertiesToSet, propertiesToExclude)
        self.recv_cloneTable()

    def send_cloneTable(self, sharedSecret, tableName, newTableName, flush, propertiesToSet, propertiesToExclude):
        self._oprot.writeMessageBegin('cloneTable', TMessageType.CALL, self._seqid)
        args = cloneTable_args()
        args.sharedSecret = sharedSecret
        args.tableName = tableName
        args.newTableName = newTableName
        args.flush = flush
        args.propertiesToSet = propertiesToSet
        args.propertiesToExclude = propertiesToExclude
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_cloneTable(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = cloneTable_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        if result.ouch4 is not None:
            raise result.ouch4
        return

    def compactTable(self, sharedSecret, tableName, startRow, endRow, iterators, flush, wait, selectorConfig, configurerConfig):
        """
        Parameters:
         - sharedSecret
         - tableName
         - startRow
         - endRow
         - iterators
         - flush
         - wait
         - selectorConfig
         - configurerConfig

        """
        self.send_compactTable(sharedSecret, tableName, startRow, endRow, iterators, flush, wait, selectorConfig, configurerConfig)
        self.recv_compactTable()

    def send_compactTable(self, sharedSecret, tableName, startRow, endRow, iterators, flush, wait, selectorConfig, configurerConfig):
        self._oprot.writeMessageBegin('compactTable', TMessageType.CALL, self._seqid)
        args = compactTable_args()
        args.sharedSecret = sharedSecret
        args.tableName = tableName
        args.startRow = startRow
        args.endRow = endRow
        args.iterators = iterators
        args.flush = flush
        args.wait = wait
        args.selectorConfig = selectorConfig
        args.configurerConfig = configurerConfig
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_compactTable(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = compactTable_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        return

    def cancelCompaction(self, sharedSecret, tableName):
        """
        Parameters:
         - sharedSecret
         - tableName

        """
        self.send_cancelCompaction(sharedSecret, tableName)
        self.recv_cancelCompaction()

    def send_cancelCompaction(self, sharedSecret, tableName):
        self._oprot.writeMessageBegin('cancelCompaction', TMessageType.CALL, self._seqid)
        args = cancelCompaction_args()
        args.sharedSecret = sharedSecret
        args.tableName = tableName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_cancelCompaction(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = cancelCompaction_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        return

    def createTable(self, sharedSecret, tableName, versioningIter, type):
        """
        Parameters:
         - sharedSecret
         - tableName
         - versioningIter
         - type

        """
        self.send_createTable(sharedSecret, tableName, versioningIter, type)
        self.recv_createTable()

    def send_createTable(self, sharedSecret, tableName, versioningIter, type):
        self._oprot.writeMessageBegin('createTable', TMessageType.CALL, self._seqid)
        args = createTable_args()
        args.sharedSecret = sharedSecret
        args.tableName = tableName
        args.versioningIter = versioningIter
        args.type = type
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createTable(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createTable_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        return

    def deleteTable(self, sharedSecret, tableName):
        """
        Parameters:
         - sharedSecret
         - tableName

        """
        self.send_deleteTable(sharedSecret, tableName)
        self.recv_deleteTable()

    def send_deleteTable(self, sharedSecret, tableName):
        self._oprot.writeMessageBegin('deleteTable', TMessageType.CALL, self._seqid)
        args = deleteTable_args()
        args.sharedSecret = sharedSecret
        args.tableName = tableName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_deleteTable(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = deleteTable_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        return

    def deleteRows(self, sharedSecret, tableName, startRow, endRow):
        """
        Parameters:
         - sharedSecret
         - tableName
         - startRow
         - endRow

        """
        self.send_deleteRows(sharedSecret, tableName, startRow, endRow)
        self.recv_deleteRows()

    def send_deleteRows(self, sharedSecret, tableName, startRow, endRow):
        self._oprot.writeMessageBegin('deleteRows', TMessageType.CALL, self._seqid)
        args = deleteRows_args()
        args.sharedSecret = sharedSecret
        args.tableName = tableName
        args.startRow = startRow
        args.endRow = endRow
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_deleteRows(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = deleteRows_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        return

    def exportTable(self, sharedSecret, tableName, exportDir):
        """
        Parameters:
         - sharedSecret
         - tableName
         - exportDir

        """
        self.send_exportTable(sharedSecret, tableName, exportDir)
        self.recv_exportTable()

    def send_exportTable(self, sharedSecret, tableName, exportDir):
        self._oprot.writeMessageBegin('exportTable', TMessageType.CALL, self._seqid)
        args = exportTable_args()
        args.sharedSecret = sharedSecret
        args.tableName = tableName
        args.exportDir = exportDir
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_exportTable(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = exportTable_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        return

    def flushTable(self, sharedSecret, tableName, startRow, endRow, wait):
        """
        Parameters:
         - sharedSecret
         - tableName
         - startRow
         - endRow
         - wait

        """
        self.send_flushTable(sharedSecret, tableName, startRow, endRow, wait)
        self.recv_flushTable()

    def send_flushTable(self, sharedSecret, tableName, startRow, endRow, wait):
        self._oprot.writeMessageBegin('flushTable', TMessageType.CALL, self._seqid)
        args = flushTable_args()
        args.sharedSecret = sharedSecret
        args.tableName = tableName
        args.startRow = startRow
        args.endRow = endRow
        args.wait = wait
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_flushTable(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = flushTable_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        return

    def getDiskUsage(self, sharedSecret, tables):
        """
        Parameters:
         - sharedSecret
         - tables

        """
        self.send_getDiskUsage(sharedSecret, tables)
        return self.recv_getDiskUsage()

    def send_getDiskUsage(self, sharedSecret, tables):
        self._oprot.writeMessageBegin('getDiskUsage', TMessageType.CALL, self._seqid)
        args = getDiskUsage_args()
        args.sharedSecret = sharedSecret
        args.tables = tables
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDiskUsage(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDiskUsage_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDiskUsage failed: unknown result")

    def getLocalityGroups(self, sharedSecret, tableName):
        """
        Parameters:
         - sharedSecret
         - tableName

        """
        self.send_getLocalityGroups(sharedSecret, tableName)
        return self.recv_getLocalityGroups()

    def send_getLocalityGroups(self, sharedSecret, tableName):
        self._oprot.writeMessageBegin('getLocalityGroups', TMessageType.CALL, self._seqid)
        args = getLocalityGroups_args()
        args.sharedSecret = sharedSecret
        args.tableName = tableName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getLocalityGroups(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getLocalityGroups_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getLocalityGroups failed: unknown result")

    def getIteratorSetting(self, sharedSecret, tableName, iteratorName, scope):
        """
        Parameters:
         - sharedSecret
         - tableName
         - iteratorName
         - scope

        """
        self.send_getIteratorSetting(sharedSecret, tableName, iteratorName, scope)
        return self.recv_getIteratorSetting()

    def send_getIteratorSetting(self, sharedSecret, tableName, iteratorName, scope):
        self._oprot.writeMessageBegin('getIteratorSetting', TMessageType.CALL, self._seqid)
        args = getIteratorSetting_args()
        args.sharedSecret = sharedSecret
        args.tableName = tableName
        args.iteratorName = iteratorName
        args.scope = scope
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getIteratorSetting(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getIteratorSetting_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getIteratorSetting failed: unknown result")

    def getMaxRow(self, sharedSecret, tableName, auths, startRow, startInclusive, endRow, endInclusive):
        """
        Parameters:
         - sharedSecret
         - tableName
         - auths
         - startRow
         - startInclusive
         - endRow
         - endInclusive

        """
        self.send_getMaxRow(sharedSecret, tableName, auths, startRow, startInclusive, endRow, endInclusive)
        return self.recv_getMaxRow()

    def send_getMaxRow(self, sharedSecret, tableName, auths, startRow, startInclusive, endRow, endInclusive):
        self._oprot.writeMessageBegin('getMaxRow', TMessageType.CALL, self._seqid)
        args = getMaxRow_args()
        args.sharedSecret = sharedSecret
        args.tableName = tableName
        args.auths = auths
        args.startRow = startRow
        args.startInclusive = startInclusive
        args.endRow = endRow
        args.endInclusive = endInclusive
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getMaxRow(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getMaxRow_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getMaxRow failed: unknown result")

    def getTableProperties(self, sharedSecret, tableName):
        """
        Parameters:
         - sharedSecret
         - tableName

        """
        self.send_getTableProperties(sharedSecret, tableName)
        return self.recv_getTableProperties()

    def send_getTableProperties(self, sharedSecret, tableName):
        self._oprot.writeMessageBegin('getTableProperties', TMessageType.CALL, self._seqid)
        args = getTableProperties_args()
        args.sharedSecret = sharedSecret
        args.tableName = tableName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getTableProperties(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getTableProperties_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getTableProperties failed: unknown result")

    def importDirectory(self, sharedSecret, tableName, importDir, failureDir, setTime):
        """
        Parameters:
         - sharedSecret
         - tableName
         - importDir
         - failureDir
         - setTime

        """
        self.send_importDirectory(sharedSecret, tableName, importDir, failureDir, setTime)
        self.recv_importDirectory()

    def send_importDirectory(self, sharedSecret, tableName, importDir, failureDir, setTime):
        self._oprot.writeMessageBegin('importDirectory', TMessageType.CALL, self._seqid)
        args = importDirectory_args()
        args.sharedSecret = sharedSecret
        args.tableName = tableName
        args.importDir = importDir
        args.failureDir = failureDir
        args.setTime = setTime
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_importDirectory(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = importDirectory_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch3 is not None:
            raise result.ouch3
        if result.ouch4 is not None:
            raise result.ouch4
        return

    def importTable(self, sharedSecret, tableName, importDir):
        """
        Parameters:
         - sharedSecret
         - tableName
         - importDir

        """
        self.send_importTable(sharedSecret, tableName, importDir)
        self.recv_importTable()

    def send_importTable(self, sharedSecret, tableName, importDir):
        self._oprot.writeMessageBegin('importTable', TMessageType.CALL, self._seqid)
        args = importTable_args()
        args.sharedSecret = sharedSecret
        args.tableName = tableName
        args.importDir = importDir
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_importTable(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = importTable_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        return

    def listSplits(self, sharedSecret, tableName, maxSplits):
        """
        Parameters:
         - sharedSecret
         - tableName
         - maxSplits

        """
        self.send_listSplits(sharedSecret, tableName, maxSplits)
        return self.recv_listSplits()

    def send_listSplits(self, sharedSecret, tableName, maxSplits):
        self._oprot.writeMessageBegin('listSplits', TMessageType.CALL, self._seqid)
        args = listSplits_args()
        args.sharedSecret = sharedSecret
        args.tableName = tableName
        args.maxSplits = maxSplits
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_listSplits(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = listSplits_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "listSplits failed: unknown result")

    def listTables(self, sharedSecret):
        """
        Parameters:
         - sharedSecret

        """
        self.send_listTables(sharedSecret)
        return self.recv_listTables()

    def send_listTables(self, sharedSecret):
        self._oprot.writeMessageBegin('listTables', TMessageType.CALL, self._seqid)
        args = listTables_args()
        args.sharedSecret = sharedSecret
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_listTables(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = listTables_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "listTables failed: unknown result")

    def listIterators(self, sharedSecret, tableName):
        """
        Parameters:
         - sharedSecret
         - tableName

        """
        self.send_listIterators(sharedSecret, tableName)
        return self.recv_listIterators()

    def send_listIterators(self, sharedSecret, tableName):
        self._oprot.writeMessageBegin('listIterators', TMessageType.CALL, self._seqid)
        args = listIterators_args()
        args.sharedSecret = sharedSecret
        args.tableName = tableName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_listIterators(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = listIterators_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "listIterators failed: unknown result")

    def listConstraints(self, sharedSecret, tableName):
        """
        Parameters:
         - sharedSecret
         - tableName

        """
        self.send_listConstraints(sharedSecret, tableName)
        return self.recv_listConstraints()

    def send_listConstraints(self, sharedSecret, tableName):
        self._oprot.writeMessageBegin('listConstraints', TMessageType.CALL, self._seqid)
        args = listConstraints_args()
        args.sharedSecret = sharedSecret
        args.tableName = tableName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_listConstraints(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = listConstraints_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "listConstraints failed: unknown result")

    def mergeTablets(self, sharedSecret, tableName, startRow, endRow):
        """
        Parameters:
         - sharedSecret
         - tableName
         - startRow
         - endRow

        """
        self.send_mergeTablets(sharedSecret, tableName, startRow, endRow)
        self.recv_mergeTablets()

    def send_mergeTablets(self, sharedSecret, tableName, startRow, endRow):
        self._oprot.writeMessageBegin('mergeTablets', TMessageType.CALL, self._seqid)
        args = mergeTablets_args()
        args.sharedSecret = sharedSecret
        args.tableName = tableName
        args.startRow = startRow
        args.endRow = endRow
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mergeTablets(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mergeTablets_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        return

    def offlineTable(self, sharedSecret, tableName, wait):
        """
        Parameters:
         - sharedSecret
         - tableName
         - wait

        """
        self.send_offlineTable(sharedSecret, tableName, wait)
        self.recv_offlineTable()

    def send_offlineTable(self, sharedSecret, tableName, wait):
        self._oprot.writeMessageBegin('offlineTable', TMessageType.CALL, self._seqid)
        args = offlineTable_args()
        args.sharedSecret = sharedSecret
        args.tableName = tableName
        args.wait = wait
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_offlineTable(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = offlineTable_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        return

    def onlineTable(self, sharedSecret, tableName, wait):
        """
        Parameters:
         - sharedSecret
         - tableName
         - wait

        """
        self.send_onlineTable(sharedSecret, tableName, wait)
        self.recv_onlineTable()

    def send_onlineTable(self, sharedSecret, tableName, wait):
        self._oprot.writeMessageBegin('onlineTable', TMessageType.CALL, self._seqid)
        args = onlineTable_args()
        args.sharedSecret = sharedSecret
        args.tableName = tableName
        args.wait = wait
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_onlineTable(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = onlineTable_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        return

    def removeConstraint(self, sharedSecret, tableName, constraint):
        """
        Parameters:
         - sharedSecret
         - tableName
         - constraint

        """
        self.send_removeConstraint(sharedSecret, tableName, constraint)
        self.recv_removeConstraint()

    def send_removeConstraint(self, sharedSecret, tableName, constraint):
        self._oprot.writeMessageBegin('removeConstraint', TMessageType.CALL, self._seqid)
        args = removeConstraint_args()
        args.sharedSecret = sharedSecret
        args.tableName = tableName
        args.constraint = constraint
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_removeConstraint(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = removeConstraint_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        return

    def removeIterator(self, sharedSecret, tableName, iterName, scopes):
        """
        Parameters:
         - sharedSecret
         - tableName
         - iterName
         - scopes

        """
        self.send_removeIterator(sharedSecret, tableName, iterName, scopes)
        self.recv_removeIterator()

    def send_removeIterator(self, sharedSecret, tableName, iterName, scopes):
        self._oprot.writeMessageBegin('removeIterator', TMessageType.CALL, self._seqid)
        args = removeIterator_args()
        args.sharedSecret = sharedSecret
        args.tableName = tableName
        args.iterName = iterName
        args.scopes = scopes
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_removeIterator(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = removeIterator_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        return

    def removeTableProperty(self, sharedSecret, tableName, property):
        """
        Parameters:
         - sharedSecret
         - tableName
         - property

        """
        self.send_removeTableProperty(sharedSecret, tableName, property)
        self.recv_removeTableProperty()

    def send_removeTableProperty(self, sharedSecret, tableName, property):
        self._oprot.writeMessageBegin('removeTableProperty', TMessageType.CALL, self._seqid)
        args = removeTableProperty_args()
        args.sharedSecret = sharedSecret
        args.tableName = tableName
        args.property = property
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_removeTableProperty(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = removeTableProperty_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        return

    def renameTable(self, sharedSecret, oldTableName, newTableName):
        """
        Parameters:
         - sharedSecret
         - oldTableName
         - newTableName

        """
        self.send_renameTable(sharedSecret, oldTableName, newTableName)
        self.recv_renameTable()

    def send_renameTable(self, sharedSecret, oldTableName, newTableName):
        self._oprot.writeMessageBegin('renameTable', TMessageType.CALL, self._seqid)
        args = renameTable_args()
        args.sharedSecret = sharedSecret
        args.oldTableName = oldTableName
        args.newTableName = newTableName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_renameTable(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = renameTable_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        if result.ouch4 is not None:
            raise result.ouch4
        return

    def setLocalityGroups(self, sharedSecret, tableName, groups):
        """
        Parameters:
         - sharedSecret
         - tableName
         - groups

        """
        self.send_setLocalityGroups(sharedSecret, tableName, groups)
        self.recv_setLocalityGroups()

    def send_setLocalityGroups(self, sharedSecret, tableName, groups):
        self._oprot.writeMessageBegin('setLocalityGroups', TMessageType.CALL, self._seqid)
        args = setLocalityGroups_args()
        args.sharedSecret = sharedSecret
        args.tableName = tableName
        args.groups = groups
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_setLocalityGroups(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = setLocalityGroups_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        return

    def setTableProperty(self, sharedSecret, tableName, property, value):
        """
        Parameters:
         - sharedSecret
         - tableName
         - property
         - value

        """
        self.send_setTableProperty(sharedSecret, tableName, property, value)
        self.recv_setTableProperty()

    def send_setTableProperty(self, sharedSecret, tableName, property, value):
        self._oprot.writeMessageBegin('setTableProperty', TMessageType.CALL, self._seqid)
        args = setTableProperty_args()
        args.sharedSecret = sharedSecret
        args.tableName = tableName
        args.property = property
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_setTableProperty(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = setTableProperty_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        return

    def splitRangeByTablets(self, sharedSecret, tableName, range, maxSplits):
        """
        Parameters:
         - sharedSecret
         - tableName
         - range
         - maxSplits

        """
        self.send_splitRangeByTablets(sharedSecret, tableName, range, maxSplits)
        return self.recv_splitRangeByTablets()

    def send_splitRangeByTablets(self, sharedSecret, tableName, range, maxSplits):
        self._oprot.writeMessageBegin('splitRangeByTablets', TMessageType.CALL, self._seqid)
        args = splitRangeByTablets_args()
        args.sharedSecret = sharedSecret
        args.tableName = tableName
        args.range = range
        args.maxSplits = maxSplits
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_splitRangeByTablets(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = splitRangeByTablets_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "splitRangeByTablets failed: unknown result")

    def tableExists(self, sharedSecret, tableName):
        """
        Parameters:
         - sharedSecret
         - tableName

        """
        self.send_tableExists(sharedSecret, tableName)
        return self.recv_tableExists()

    def send_tableExists(self, sharedSecret, tableName):
        self._oprot.writeMessageBegin('tableExists', TMessageType.CALL, self._seqid)
        args = tableExists_args()
        args.sharedSecret = sharedSecret
        args.tableName = tableName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_tableExists(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = tableExists_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "tableExists failed: unknown result")

    def tableIdMap(self, sharedSecret):
        """
        Parameters:
         - sharedSecret

        """
        self.send_tableIdMap(sharedSecret)
        return self.recv_tableIdMap()

    def send_tableIdMap(self, sharedSecret):
        self._oprot.writeMessageBegin('tableIdMap', TMessageType.CALL, self._seqid)
        args = tableIdMap_args()
        args.sharedSecret = sharedSecret
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_tableIdMap(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = tableIdMap_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "tableIdMap failed: unknown result")

    def testTableClassLoad(self, sharedSecret, tableName, className, asTypeName):
        """
        Parameters:
         - sharedSecret
         - tableName
         - className
         - asTypeName

        """
        self.send_testTableClassLoad(sharedSecret, tableName, className, asTypeName)
        return self.recv_testTableClassLoad()

    def send_testTableClassLoad(self, sharedSecret, tableName, className, asTypeName):
        self._oprot.writeMessageBegin('testTableClassLoad', TMessageType.CALL, self._seqid)
        args = testTableClassLoad_args()
        args.sharedSecret = sharedSecret
        args.tableName = tableName
        args.className = className
        args.asTypeName = asTypeName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_testTableClassLoad(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = testTableClassLoad_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "testTableClassLoad failed: unknown result")

    def pingTabletServer(self, sharedSecret, tserver):
        """
        Parameters:
         - sharedSecret
         - tserver

        """
        self.send_pingTabletServer(sharedSecret, tserver)
        self.recv_pingTabletServer()

    def send_pingTabletServer(self, sharedSecret, tserver):
        self._oprot.writeMessageBegin('pingTabletServer', TMessageType.CALL, self._seqid)
        args = pingTabletServer_args()
        args.sharedSecret = sharedSecret
        args.tserver = tserver
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pingTabletServer(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pingTabletServer_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        return

    def getActiveScans(self, sharedSecret, tserver):
        """
        Parameters:
         - sharedSecret
         - tserver

        """
        self.send_getActiveScans(sharedSecret, tserver)
        return self.recv_getActiveScans()

    def send_getActiveScans(self, sharedSecret, tserver):
        self._oprot.writeMessageBegin('getActiveScans', TMessageType.CALL, self._seqid)
        args = getActiveScans_args()
        args.sharedSecret = sharedSecret
        args.tserver = tserver
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getActiveScans(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getActiveScans_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getActiveScans failed: unknown result")

    def getActiveCompactions(self, sharedSecret, tserver):
        """
        Parameters:
         - sharedSecret
         - tserver

        """
        self.send_getActiveCompactions(sharedSecret, tserver)
        return self.recv_getActiveCompactions()

    def send_getActiveCompactions(self, sharedSecret, tserver):
        self._oprot.writeMessageBegin('getActiveCompactions', TMessageType.CALL, self._seqid)
        args = getActiveCompactions_args()
        args.sharedSecret = sharedSecret
        args.tserver = tserver
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getActiveCompactions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getActiveCompactions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getActiveCompactions failed: unknown result")

    def getSiteConfiguration(self, sharedSecret):
        """
        Parameters:
         - sharedSecret

        """
        self.send_getSiteConfiguration(sharedSecret)
        return self.recv_getSiteConfiguration()

    def send_getSiteConfiguration(self, sharedSecret):
        self._oprot.writeMessageBegin('getSiteConfiguration', TMessageType.CALL, self._seqid)
        args = getSiteConfiguration_args()
        args.sharedSecret = sharedSecret
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getSiteConfiguration(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getSiteConfiguration_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getSiteConfiguration failed: unknown result")

    def getSystemConfiguration(self, sharedSecret):
        """
        Parameters:
         - sharedSecret

        """
        self.send_getSystemConfiguration(sharedSecret)
        return self.recv_getSystemConfiguration()

    def send_getSystemConfiguration(self, sharedSecret):
        self._oprot.writeMessageBegin('getSystemConfiguration', TMessageType.CALL, self._seqid)
        args = getSystemConfiguration_args()
        args.sharedSecret = sharedSecret
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getSystemConfiguration(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getSystemConfiguration_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getSystemConfiguration failed: unknown result")

    def getTabletServers(self, sharedSecret):
        """
        Parameters:
         - sharedSecret

        """
        self.send_getTabletServers(sharedSecret)
        return self.recv_getTabletServers()

    def send_getTabletServers(self, sharedSecret):
        self._oprot.writeMessageBegin('getTabletServers', TMessageType.CALL, self._seqid)
        args = getTabletServers_args()
        args.sharedSecret = sharedSecret
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getTabletServers(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getTabletServers_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getTabletServers failed: unknown result")

    def removeProperty(self, sharedSecret, property):
        """
        Parameters:
         - sharedSecret
         - property

        """
        self.send_removeProperty(sharedSecret, property)
        self.recv_removeProperty()

    def send_removeProperty(self, sharedSecret, property):
        self._oprot.writeMessageBegin('removeProperty', TMessageType.CALL, self._seqid)
        args = removeProperty_args()
        args.sharedSecret = sharedSecret
        args.property = property
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_removeProperty(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = removeProperty_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        return

    def setProperty(self, sharedSecret, property, value):
        """
        Parameters:
         - sharedSecret
         - property
         - value

        """
        self.send_setProperty(sharedSecret, property, value)
        self.recv_setProperty()

    def send_setProperty(self, sharedSecret, property, value):
        self._oprot.writeMessageBegin('setProperty', TMessageType.CALL, self._seqid)
        args = setProperty_args()
        args.sharedSecret = sharedSecret
        args.property = property
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_setProperty(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = setProperty_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        return

    def testClassLoad(self, sharedSecret, className, asTypeName):
        """
        Parameters:
         - sharedSecret
         - className
         - asTypeName

        """
        self.send_testClassLoad(sharedSecret, className, asTypeName)
        return self.recv_testClassLoad()

    def send_testClassLoad(self, sharedSecret, className, asTypeName):
        self._oprot.writeMessageBegin('testClassLoad', TMessageType.CALL, self._seqid)
        args = testClassLoad_args()
        args.sharedSecret = sharedSecret
        args.className = className
        args.asTypeName = asTypeName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_testClassLoad(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = testClassLoad_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "testClassLoad failed: unknown result")

    def authenticateUser(self, sharedSecret, user, properties):
        """
        Parameters:
         - sharedSecret
         - user
         - properties

        """
        self.send_authenticateUser(sharedSecret, user, properties)
        return self.recv_authenticateUser()

    def send_authenticateUser(self, sharedSecret, user, properties):
        self._oprot.writeMessageBegin('authenticateUser', TMessageType.CALL, self._seqid)
        args = authenticateUser_args()
        args.sharedSecret = sharedSecret
        args.user = user
        args.properties = properties
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_authenticateUser(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = authenticateUser_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "authenticateUser failed: unknown result")

    def changeUserAuthorizations(self, sharedSecret, user, authorizations):
        """
        Parameters:
         - sharedSecret
         - user
         - authorizations

        """
        self.send_changeUserAuthorizations(sharedSecret, user, authorizations)
        self.recv_changeUserAuthorizations()

    def send_changeUserAuthorizations(self, sharedSecret, user, authorizations):
        self._oprot.writeMessageBegin('changeUserAuthorizations', TMessageType.CALL, self._seqid)
        args = changeUserAuthorizations_args()
        args.sharedSecret = sharedSecret
        args.user = user
        args.authorizations = authorizations
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_changeUserAuthorizations(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = changeUserAuthorizations_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        return

    def changeLocalUserPassword(self, sharedSecret, user, password):
        """
        Parameters:
         - sharedSecret
         - user
         - password

        """
        self.send_changeLocalUserPassword(sharedSecret, user, password)
        self.recv_changeLocalUserPassword()

    def send_changeLocalUserPassword(self, sharedSecret, user, password):
        self._oprot.writeMessageBegin('changeLocalUserPassword', TMessageType.CALL, self._seqid)
        args = changeLocalUserPassword_args()
        args.sharedSecret = sharedSecret
        args.user = user
        args.password = password
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_changeLocalUserPassword(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = changeLocalUserPassword_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        return

    def createLocalUser(self, sharedSecret, user, password):
        """
        Parameters:
         - sharedSecret
         - user
         - password

        """
        self.send_createLocalUser(sharedSecret, user, password)
        self.recv_createLocalUser()

    def send_createLocalUser(self, sharedSecret, user, password):
        self._oprot.writeMessageBegin('createLocalUser', TMessageType.CALL, self._seqid)
        args = createLocalUser_args()
        args.sharedSecret = sharedSecret
        args.user = user
        args.password = password
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createLocalUser(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createLocalUser_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        return

    def dropLocalUser(self, sharedSecret, user):
        """
        Parameters:
         - sharedSecret
         - user

        """
        self.send_dropLocalUser(sharedSecret, user)
        self.recv_dropLocalUser()

    def send_dropLocalUser(self, sharedSecret, user):
        self._oprot.writeMessageBegin('dropLocalUser', TMessageType.CALL, self._seqid)
        args = dropLocalUser_args()
        args.sharedSecret = sharedSecret
        args.user = user
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_dropLocalUser(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = dropLocalUser_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        return

    def getUserAuthorizations(self, sharedSecret, user):
        """
        Parameters:
         - sharedSecret
         - user

        """
        self.send_getUserAuthorizations(sharedSecret, user)
        return self.recv_getUserAuthorizations()

    def send_getUserAuthorizations(self, sharedSecret, user):
        self._oprot.writeMessageBegin('getUserAuthorizations', TMessageType.CALL, self._seqid)
        args = getUserAuthorizations_args()
        args.sharedSecret = sharedSecret
        args.user = user
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getUserAuthorizations(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getUserAuthorizations_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getUserAuthorizations failed: unknown result")

    def grantSystemPermission(self, sharedSecret, user, perm):
        """
        Parameters:
         - sharedSecret
         - user
         - perm

        """
        self.send_grantSystemPermission(sharedSecret, user, perm)
        self.recv_grantSystemPermission()

    def send_grantSystemPermission(self, sharedSecret, user, perm):
        self._oprot.writeMessageBegin('grantSystemPermission', TMessageType.CALL, self._seqid)
        args = grantSystemPermission_args()
        args.sharedSecret = sharedSecret
        args.user = user
        args.perm = perm
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_grantSystemPermission(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = grantSystemPermission_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        return

    def grantTablePermission(self, sharedSecret, user, table, perm):
        """
        Parameters:
         - sharedSecret
         - user
         - table
         - perm

        """
        self.send_grantTablePermission(sharedSecret, user, table, perm)
        self.recv_grantTablePermission()

    def send_grantTablePermission(self, sharedSecret, user, table, perm):
        self._oprot.writeMessageBegin('grantTablePermission', TMessageType.CALL, self._seqid)
        args = grantTablePermission_args()
        args.sharedSecret = sharedSecret
        args.user = user
        args.table = table
        args.perm = perm
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_grantTablePermission(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = grantTablePermission_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        return

    def hasSystemPermission(self, sharedSecret, user, perm):
        """
        Parameters:
         - sharedSecret
         - user
         - perm

        """
        self.send_hasSystemPermission(sharedSecret, user, perm)
        return self.recv_hasSystemPermission()

    def send_hasSystemPermission(self, sharedSecret, user, perm):
        self._oprot.writeMessageBegin('hasSystemPermission', TMessageType.CALL, self._seqid)
        args = hasSystemPermission_args()
        args.sharedSecret = sharedSecret
        args.user = user
        args.perm = perm
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_hasSystemPermission(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = hasSystemPermission_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "hasSystemPermission failed: unknown result")

    def hasTablePermission(self, sharedSecret, user, table, perm):
        """
        Parameters:
         - sharedSecret
         - user
         - table
         - perm

        """
        self.send_hasTablePermission(sharedSecret, user, table, perm)
        return self.recv_hasTablePermission()

    def send_hasTablePermission(self, sharedSecret, user, table, perm):
        self._oprot.writeMessageBegin('hasTablePermission', TMessageType.CALL, self._seqid)
        args = hasTablePermission_args()
        args.sharedSecret = sharedSecret
        args.user = user
        args.table = table
        args.perm = perm
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_hasTablePermission(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = hasTablePermission_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "hasTablePermission failed: unknown result")

    def listLocalUsers(self, sharedSecret):
        """
        Parameters:
         - sharedSecret

        """
        self.send_listLocalUsers(sharedSecret)
        return self.recv_listLocalUsers()

    def send_listLocalUsers(self, sharedSecret):
        self._oprot.writeMessageBegin('listLocalUsers', TMessageType.CALL, self._seqid)
        args = listLocalUsers_args()
        args.sharedSecret = sharedSecret
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_listLocalUsers(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = listLocalUsers_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "listLocalUsers failed: unknown result")

    def revokeSystemPermission(self, sharedSecret, user, perm):
        """
        Parameters:
         - sharedSecret
         - user
         - perm

        """
        self.send_revokeSystemPermission(sharedSecret, user, perm)
        self.recv_revokeSystemPermission()

    def send_revokeSystemPermission(self, sharedSecret, user, perm):
        self._oprot.writeMessageBegin('revokeSystemPermission', TMessageType.CALL, self._seqid)
        args = revokeSystemPermission_args()
        args.sharedSecret = sharedSecret
        args.user = user
        args.perm = perm
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_revokeSystemPermission(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = revokeSystemPermission_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        return

    def revokeTablePermission(self, sharedSecret, user, table, perm):
        """
        Parameters:
         - sharedSecret
         - user
         - table
         - perm

        """
        self.send_revokeTablePermission(sharedSecret, user, table, perm)
        self.recv_revokeTablePermission()

    def send_revokeTablePermission(self, sharedSecret, user, table, perm):
        self._oprot.writeMessageBegin('revokeTablePermission', TMessageType.CALL, self._seqid)
        args = revokeTablePermission_args()
        args.sharedSecret = sharedSecret
        args.user = user
        args.table = table
        args.perm = perm
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_revokeTablePermission(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = revokeTablePermission_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        return

    def grantNamespacePermission(self, sharedSecret, user, namespaceName, perm):
        """
        Parameters:
         - sharedSecret
         - user
         - namespaceName
         - perm

        """
        self.send_grantNamespacePermission(sharedSecret, user, namespaceName, perm)
        self.recv_grantNamespacePermission()

    def send_grantNamespacePermission(self, sharedSecret, user, namespaceName, perm):
        self._oprot.writeMessageBegin('grantNamespacePermission', TMessageType.CALL, self._seqid)
        args = grantNamespacePermission_args()
        args.sharedSecret = sharedSecret
        args.user = user
        args.namespaceName = namespaceName
        args.perm = perm
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_grantNamespacePermission(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = grantNamespacePermission_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        return

    def hasNamespacePermission(self, sharedSecret, user, namespaceName, perm):
        """
        Parameters:
         - sharedSecret
         - user
         - namespaceName
         - perm

        """
        self.send_hasNamespacePermission(sharedSecret, user, namespaceName, perm)
        return self.recv_hasNamespacePermission()

    def send_hasNamespacePermission(self, sharedSecret, user, namespaceName, perm):
        self._oprot.writeMessageBegin('hasNamespacePermission', TMessageType.CALL, self._seqid)
        args = hasNamespacePermission_args()
        args.sharedSecret = sharedSecret
        args.user = user
        args.namespaceName = namespaceName
        args.perm = perm
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_hasNamespacePermission(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = hasNamespacePermission_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "hasNamespacePermission failed: unknown result")

    def revokeNamespacePermission(self, sharedSecret, user, namespaceName, perm):
        """
        Parameters:
         - sharedSecret
         - user
         - namespaceName
         - perm

        """
        self.send_revokeNamespacePermission(sharedSecret, user, namespaceName, perm)
        self.recv_revokeNamespacePermission()

    def send_revokeNamespacePermission(self, sharedSecret, user, namespaceName, perm):
        self._oprot.writeMessageBegin('revokeNamespacePermission', TMessageType.CALL, self._seqid)
        args = revokeNamespacePermission_args()
        args.sharedSecret = sharedSecret
        args.user = user
        args.namespaceName = namespaceName
        args.perm = perm
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_revokeNamespacePermission(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = revokeNamespacePermission_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        return

    def createBatchScanner(self, sharedSecret, tableName, options):
        """
        Parameters:
         - sharedSecret
         - tableName
         - options

        """
        self.send_createBatchScanner(sharedSecret, tableName, options)
        return self.recv_createBatchScanner()

    def send_createBatchScanner(self, sharedSecret, tableName, options):
        self._oprot.writeMessageBegin('createBatchScanner', TMessageType.CALL, self._seqid)
        args = createBatchScanner_args()
        args.sharedSecret = sharedSecret
        args.tableName = tableName
        args.options = options
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createBatchScanner(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createBatchScanner_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "createBatchScanner failed: unknown result")

    def createScanner(self, sharedSecret, tableName, options):
        """
        Parameters:
         - sharedSecret
         - tableName
         - options

        """
        self.send_createScanner(sharedSecret, tableName, options)
        return self.recv_createScanner()

    def send_createScanner(self, sharedSecret, tableName, options):
        self._oprot.writeMessageBegin('createScanner', TMessageType.CALL, self._seqid)
        args = createScanner_args()
        args.sharedSecret = sharedSecret
        args.tableName = tableName
        args.options = options
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createScanner(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createScanner_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "createScanner failed: unknown result")

    def hasNext(self, scanner):
        """
        Parameters:
         - scanner

        """
        self.send_hasNext(scanner)
        return self.recv_hasNext()

    def send_hasNext(self, scanner):
        self._oprot.writeMessageBegin('hasNext', TMessageType.CALL, self._seqid)
        args = hasNext_args()
        args.scanner = scanner
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_hasNext(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = hasNext_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch1 is not None:
            raise result.ouch1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "hasNext failed: unknown result")

    def nextEntry(self, scanner):
        """
        Parameters:
         - scanner

        """
        self.send_nextEntry(scanner)
        return self.recv_nextEntry()

    def send_nextEntry(self, scanner):
        self._oprot.writeMessageBegin('nextEntry', TMessageType.CALL, self._seqid)
        args = nextEntry_args()
        args.scanner = scanner
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_nextEntry(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = nextEntry_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "nextEntry failed: unknown result")

    def nextK(self, scanner, k):
        """
        Parameters:
         - scanner
         - k

        """
        self.send_nextK(scanner, k)
        return self.recv_nextK()

    def send_nextK(self, scanner, k):
        self._oprot.writeMessageBegin('nextK', TMessageType.CALL, self._seqid)
        args = nextK_args()
        args.scanner = scanner
        args.k = k
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_nextK(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = nextK_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "nextK failed: unknown result")

    def closeScanner(self, scanner):
        """
        Parameters:
         - scanner

        """
        self.send_closeScanner(scanner)
        self.recv_closeScanner()

    def send_closeScanner(self, scanner):
        self._oprot.writeMessageBegin('closeScanner', TMessageType.CALL, self._seqid)
        args = closeScanner_args()
        args.scanner = scanner
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_closeScanner(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = closeScanner_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        return

    def updateAndFlush(self, sharedSecret, tableName, cells):
        """
        Parameters:
         - sharedSecret
         - tableName
         - cells

        """
        self.send_updateAndFlush(sharedSecret, tableName, cells)
        self.recv_updateAndFlush()

    def send_updateAndFlush(self, sharedSecret, tableName, cells):
        self._oprot.writeMessageBegin('updateAndFlush', TMessageType.CALL, self._seqid)
        args = updateAndFlush_args()
        args.sharedSecret = sharedSecret
        args.tableName = tableName
        args.cells = cells
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateAndFlush(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateAndFlush_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.outch1 is not None:
            raise result.outch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        if result.ouch4 is not None:
            raise result.ouch4
        return

    def createWriter(self, sharedSecret, tableName, opts):
        """
        Parameters:
         - sharedSecret
         - tableName
         - opts

        """
        self.send_createWriter(sharedSecret, tableName, opts)
        return self.recv_createWriter()

    def send_createWriter(self, sharedSecret, tableName, opts):
        self._oprot.writeMessageBegin('createWriter', TMessageType.CALL, self._seqid)
        args = createWriter_args()
        args.sharedSecret = sharedSecret
        args.tableName = tableName
        args.opts = opts
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createWriter(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createWriter_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.outch1 is not None:
            raise result.outch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "createWriter failed: unknown result")

    def update(self, writer, cells):
        """
        Parameters:
         - writer
         - cells

        """
        self.send_update(writer, cells)

    def send_update(self, writer, cells):
        self._oprot.writeMessageBegin('update', TMessageType.ONEWAY, self._seqid)
        args = update_args()
        args.writer = writer
        args.cells = cells
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def flush(self, writer):
        """
        Parameters:
         - writer

        """
        self.send_flush(writer)
        self.recv_flush()

    def send_flush(self, writer):
        self._oprot.writeMessageBegin('flush', TMessageType.CALL, self._seqid)
        args = flush_args()
        args.writer = writer
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_flush(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = flush_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        return

    def closeWriter(self, writer):
        """
        Parameters:
         - writer

        """
        self.send_closeWriter(writer)
        self.recv_closeWriter()

    def send_closeWriter(self, writer):
        self._oprot.writeMessageBegin('closeWriter', TMessageType.CALL, self._seqid)
        args = closeWriter_args()
        args.writer = writer
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_closeWriter(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = closeWriter_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        return

    def updateRowConditionally(self, sharedSecret, tableName, row, updates):
        """
        Parameters:
         - sharedSecret
         - tableName
         - row
         - updates

        """
        self.send_updateRowConditionally(sharedSecret, tableName, row, updates)
        return self.recv_updateRowConditionally()

    def send_updateRowConditionally(self, sharedSecret, tableName, row, updates):
        self._oprot.writeMessageBegin('updateRowConditionally', TMessageType.CALL, self._seqid)
        args = updateRowConditionally_args()
        args.sharedSecret = sharedSecret
        args.tableName = tableName
        args.row = row
        args.updates = updates
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateRowConditionally(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateRowConditionally_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "updateRowConditionally failed: unknown result")

    def createConditionalWriter(self, sharedSecret, tableName, options):
        """
        Parameters:
         - sharedSecret
         - tableName
         - options

        """
        self.send_createConditionalWriter(sharedSecret, tableName, options)
        return self.recv_createConditionalWriter()

    def send_createConditionalWriter(self, sharedSecret, tableName, options):
        self._oprot.writeMessageBegin('createConditionalWriter', TMessageType.CALL, self._seqid)
        args = createConditionalWriter_args()
        args.sharedSecret = sharedSecret
        args.tableName = tableName
        args.options = options
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createConditionalWriter(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createConditionalWriter_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "createConditionalWriter failed: unknown result")

    def updateRowsConditionally(self, conditionalWriter, updates):
        """
        Parameters:
         - conditionalWriter
         - updates

        """
        self.send_updateRowsConditionally(conditionalWriter, updates)
        return self.recv_updateRowsConditionally()

    def send_updateRowsConditionally(self, conditionalWriter, updates):
        self._oprot.writeMessageBegin('updateRowsConditionally', TMessageType.CALL, self._seqid)
        args = updateRowsConditionally_args()
        args.conditionalWriter = conditionalWriter
        args.updates = updates
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateRowsConditionally(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateRowsConditionally_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "updateRowsConditionally failed: unknown result")

    def closeConditionalWriter(self, conditionalWriter):
        """
        Parameters:
         - conditionalWriter

        """
        self.send_closeConditionalWriter(conditionalWriter)
        self.recv_closeConditionalWriter()

    def send_closeConditionalWriter(self, conditionalWriter):
        self._oprot.writeMessageBegin('closeConditionalWriter', TMessageType.CALL, self._seqid)
        args = closeConditionalWriter_args()
        args.conditionalWriter = conditionalWriter
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_closeConditionalWriter(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = closeConditionalWriter_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def getRowRange(self, row):
        """
        Parameters:
         - row

        """
        self.send_getRowRange(row)
        return self.recv_getRowRange()

    def send_getRowRange(self, row):
        self._oprot.writeMessageBegin('getRowRange', TMessageType.CALL, self._seqid)
        args = getRowRange_args()
        args.row = row
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getRowRange(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getRowRange_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getRowRange failed: unknown result")

    def getFollowing(self, key, part):
        """
        Parameters:
         - key
         - part

        """
        self.send_getFollowing(key, part)
        return self.recv_getFollowing()

    def send_getFollowing(self, key, part):
        self._oprot.writeMessageBegin('getFollowing', TMessageType.CALL, self._seqid)
        args = getFollowing_args()
        args.key = key
        args.part = part
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getFollowing(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getFollowing_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getFollowing failed: unknown result")

    def systemNamespace(self):
        self.send_systemNamespace()
        return self.recv_systemNamespace()

    def send_systemNamespace(self):
        self._oprot.writeMessageBegin('systemNamespace', TMessageType.CALL, self._seqid)
        args = systemNamespace_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_systemNamespace(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = systemNamespace_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "systemNamespace failed: unknown result")

    def defaultNamespace(self):
        self.send_defaultNamespace()
        return self.recv_defaultNamespace()

    def send_defaultNamespace(self):
        self._oprot.writeMessageBegin('defaultNamespace', TMessageType.CALL, self._seqid)
        args = defaultNamespace_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_defaultNamespace(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = defaultNamespace_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "defaultNamespace failed: unknown result")

    def listNamespaces(self, sharedSecret):
        """
        Parameters:
         - sharedSecret

        """
        self.send_listNamespaces(sharedSecret)
        return self.recv_listNamespaces()

    def send_listNamespaces(self, sharedSecret):
        self._oprot.writeMessageBegin('listNamespaces', TMessageType.CALL, self._seqid)
        args = listNamespaces_args()
        args.sharedSecret = sharedSecret
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_listNamespaces(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = listNamespaces_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "listNamespaces failed: unknown result")

    def namespaceExists(self, sharedSecret, namespaceName):
        """
        Parameters:
         - sharedSecret
         - namespaceName

        """
        self.send_namespaceExists(sharedSecret, namespaceName)
        return self.recv_namespaceExists()

    def send_namespaceExists(self, sharedSecret, namespaceName):
        self._oprot.writeMessageBegin('namespaceExists', TMessageType.CALL, self._seqid)
        args = namespaceExists_args()
        args.sharedSecret = sharedSecret
        args.namespaceName = namespaceName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_namespaceExists(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = namespaceExists_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "namespaceExists failed: unknown result")

    def createNamespace(self, sharedSecret, namespaceName):
        """
        Parameters:
         - sharedSecret
         - namespaceName

        """
        self.send_createNamespace(sharedSecret, namespaceName)
        self.recv_createNamespace()

    def send_createNamespace(self, sharedSecret, namespaceName):
        self._oprot.writeMessageBegin('createNamespace', TMessageType.CALL, self._seqid)
        args = createNamespace_args()
        args.sharedSecret = sharedSecret
        args.namespaceName = namespaceName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createNamespace(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createNamespace_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        return

    def deleteNamespace(self, sharedSecret, namespaceName):
        """
        Parameters:
         - sharedSecret
         - namespaceName

        """
        self.send_deleteNamespace(sharedSecret, namespaceName)
        self.recv_deleteNamespace()

    def send_deleteNamespace(self, sharedSecret, namespaceName):
        self._oprot.writeMessageBegin('deleteNamespace', TMessageType.CALL, self._seqid)
        args = deleteNamespace_args()
        args.sharedSecret = sharedSecret
        args.namespaceName = namespaceName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_deleteNamespace(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = deleteNamespace_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        if result.ouch4 is not None:
            raise result.ouch4
        return

    def renameNamespace(self, sharedSecret, oldNamespaceName, newNamespaceName):
        """
        Parameters:
         - sharedSecret
         - oldNamespaceName
         - newNamespaceName

        """
        self.send_renameNamespace(sharedSecret, oldNamespaceName, newNamespaceName)
        self.recv_renameNamespace()

    def send_renameNamespace(self, sharedSecret, oldNamespaceName, newNamespaceName):
        self._oprot.writeMessageBegin('renameNamespace', TMessageType.CALL, self._seqid)
        args = renameNamespace_args()
        args.sharedSecret = sharedSecret
        args.oldNamespaceName = oldNamespaceName
        args.newNamespaceName = newNamespaceName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_renameNamespace(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = renameNamespace_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        if result.ouch4 is not None:
            raise result.ouch4
        return

    def setNamespaceProperty(self, sharedSecret, namespaceName, property, value):
        """
        Parameters:
         - sharedSecret
         - namespaceName
         - property
         - value

        """
        self.send_setNamespaceProperty(sharedSecret, namespaceName, property, value)
        self.recv_setNamespaceProperty()

    def send_setNamespaceProperty(self, sharedSecret, namespaceName, property, value):
        self._oprot.writeMessageBegin('setNamespaceProperty', TMessageType.CALL, self._seqid)
        args = setNamespaceProperty_args()
        args.sharedSecret = sharedSecret
        args.namespaceName = namespaceName
        args.property = property
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_setNamespaceProperty(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = setNamespaceProperty_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        return

    def removeNamespaceProperty(self, sharedSecret, namespaceName, property):
        """
        Parameters:
         - sharedSecret
         - namespaceName
         - property

        """
        self.send_removeNamespaceProperty(sharedSecret, namespaceName, property)
        self.recv_removeNamespaceProperty()

    def send_removeNamespaceProperty(self, sharedSecret, namespaceName, property):
        self._oprot.writeMessageBegin('removeNamespaceProperty', TMessageType.CALL, self._seqid)
        args = removeNamespaceProperty_args()
        args.sharedSecret = sharedSecret
        args.namespaceName = namespaceName
        args.property = property
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_removeNamespaceProperty(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = removeNamespaceProperty_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        return

    def getNamespaceProperties(self, sharedSecret, namespaceName):
        """
        Parameters:
         - sharedSecret
         - namespaceName

        """
        self.send_getNamespaceProperties(sharedSecret, namespaceName)
        return self.recv_getNamespaceProperties()

    def send_getNamespaceProperties(self, sharedSecret, namespaceName):
        self._oprot.writeMessageBegin('getNamespaceProperties', TMessageType.CALL, self._seqid)
        args = getNamespaceProperties_args()
        args.sharedSecret = sharedSecret
        args.namespaceName = namespaceName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getNamespaceProperties(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getNamespaceProperties_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getNamespaceProperties failed: unknown result")

    def namespaceIdMap(self, sharedSecret):
        """
        Parameters:
         - sharedSecret

        """
        self.send_namespaceIdMap(sharedSecret)
        return self.recv_namespaceIdMap()

    def send_namespaceIdMap(self, sharedSecret):
        self._oprot.writeMessageBegin('namespaceIdMap', TMessageType.CALL, self._seqid)
        args = namespaceIdMap_args()
        args.sharedSecret = sharedSecret
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_namespaceIdMap(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = namespaceIdMap_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "namespaceIdMap failed: unknown result")

    def attachNamespaceIterator(self, sharedSecret, namespaceName, setting, scopes):
        """
        Parameters:
         - sharedSecret
         - namespaceName
         - setting
         - scopes

        """
        self.send_attachNamespaceIterator(sharedSecret, namespaceName, setting, scopes)
        self.recv_attachNamespaceIterator()

    def send_attachNamespaceIterator(self, sharedSecret, namespaceName, setting, scopes):
        self._oprot.writeMessageBegin('attachNamespaceIterator', TMessageType.CALL, self._seqid)
        args = attachNamespaceIterator_args()
        args.sharedSecret = sharedSecret
        args.namespaceName = namespaceName
        args.setting = setting
        args.scopes = scopes
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_attachNamespaceIterator(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = attachNamespaceIterator_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        return

    def removeNamespaceIterator(self, sharedSecret, namespaceName, name, scopes):
        """
        Parameters:
         - sharedSecret
         - namespaceName
         - name
         - scopes

        """
        self.send_removeNamespaceIterator(sharedSecret, namespaceName, name, scopes)
        self.recv_removeNamespaceIterator()

    def send_removeNamespaceIterator(self, sharedSecret, namespaceName, name, scopes):
        self._oprot.writeMessageBegin('removeNamespaceIterator', TMessageType.CALL, self._seqid)
        args = removeNamespaceIterator_args()
        args.sharedSecret = sharedSecret
        args.namespaceName = namespaceName
        args.name = name
        args.scopes = scopes
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_removeNamespaceIterator(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = removeNamespaceIterator_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        return

    def getNamespaceIteratorSetting(self, sharedSecret, namespaceName, name, scope):
        """
        Parameters:
         - sharedSecret
         - namespaceName
         - name
         - scope

        """
        self.send_getNamespaceIteratorSetting(sharedSecret, namespaceName, name, scope)
        return self.recv_getNamespaceIteratorSetting()

    def send_getNamespaceIteratorSetting(self, sharedSecret, namespaceName, name, scope):
        self._oprot.writeMessageBegin('getNamespaceIteratorSetting', TMessageType.CALL, self._seqid)
        args = getNamespaceIteratorSetting_args()
        args.sharedSecret = sharedSecret
        args.namespaceName = namespaceName
        args.name = name
        args.scope = scope
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getNamespaceIteratorSetting(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getNamespaceIteratorSetting_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getNamespaceIteratorSetting failed: unknown result")

    def listNamespaceIterators(self, sharedSecret, namespaceName):
        """
        Parameters:
         - sharedSecret
         - namespaceName

        """
        self.send_listNamespaceIterators(sharedSecret, namespaceName)
        return self.recv_listNamespaceIterators()

    def send_listNamespaceIterators(self, sharedSecret, namespaceName):
        self._oprot.writeMessageBegin('listNamespaceIterators', TMessageType.CALL, self._seqid)
        args = listNamespaceIterators_args()
        args.sharedSecret = sharedSecret
        args.namespaceName = namespaceName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_listNamespaceIterators(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = listNamespaceIterators_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "listNamespaceIterators failed: unknown result")

    def checkNamespaceIteratorConflicts(self, sharedSecret, namespaceName, setting, scopes):
        """
        Parameters:
         - sharedSecret
         - namespaceName
         - setting
         - scopes

        """
        self.send_checkNamespaceIteratorConflicts(sharedSecret, namespaceName, setting, scopes)
        self.recv_checkNamespaceIteratorConflicts()

    def send_checkNamespaceIteratorConflicts(self, sharedSecret, namespaceName, setting, scopes):
        self._oprot.writeMessageBegin('checkNamespaceIteratorConflicts', TMessageType.CALL, self._seqid)
        args = checkNamespaceIteratorConflicts_args()
        args.sharedSecret = sharedSecret
        args.namespaceName = namespaceName
        args.setting = setting
        args.scopes = scopes
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_checkNamespaceIteratorConflicts(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = checkNamespaceIteratorConflicts_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        return

    def addNamespaceConstraint(self, sharedSecret, namespaceName, constraintClassName):
        """
        Parameters:
         - sharedSecret
         - namespaceName
         - constraintClassName

        """
        self.send_addNamespaceConstraint(sharedSecret, namespaceName, constraintClassName)
        return self.recv_addNamespaceConstraint()

    def send_addNamespaceConstraint(self, sharedSecret, namespaceName, constraintClassName):
        self._oprot.writeMessageBegin('addNamespaceConstraint', TMessageType.CALL, self._seqid)
        args = addNamespaceConstraint_args()
        args.sharedSecret = sharedSecret
        args.namespaceName = namespaceName
        args.constraintClassName = constraintClassName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_addNamespaceConstraint(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = addNamespaceConstraint_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "addNamespaceConstraint failed: unknown result")

    def removeNamespaceConstraint(self, sharedSecret, namespaceName, id):
        """
        Parameters:
         - sharedSecret
         - namespaceName
         - id

        """
        self.send_removeNamespaceConstraint(sharedSecret, namespaceName, id)
        self.recv_removeNamespaceConstraint()

    def send_removeNamespaceConstraint(self, sharedSecret, namespaceName, id):
        self._oprot.writeMessageBegin('removeNamespaceConstraint', TMessageType.CALL, self._seqid)
        args = removeNamespaceConstraint_args()
        args.sharedSecret = sharedSecret
        args.namespaceName = namespaceName
        args.id = id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_removeNamespaceConstraint(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = removeNamespaceConstraint_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        return

    def listNamespaceConstraints(self, sharedSecret, namespaceName):
        """
        Parameters:
         - sharedSecret
         - namespaceName

        """
        self.send_listNamespaceConstraints(sharedSecret, namespaceName)
        return self.recv_listNamespaceConstraints()

    def send_listNamespaceConstraints(self, sharedSecret, namespaceName):
        self._oprot.writeMessageBegin('listNamespaceConstraints', TMessageType.CALL, self._seqid)
        args = listNamespaceConstraints_args()
        args.sharedSecret = sharedSecret
        args.namespaceName = namespaceName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_listNamespaceConstraints(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = listNamespaceConstraints_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "listNamespaceConstraints failed: unknown result")

    def testNamespaceClassLoad(self, sharedSecret, namespaceName, className, asTypeName):
        """
        Parameters:
         - sharedSecret
         - namespaceName
         - className
         - asTypeName

        """
        self.send_testNamespaceClassLoad(sharedSecret, namespaceName, className, asTypeName)
        return self.recv_testNamespaceClassLoad()

    def send_testNamespaceClassLoad(self, sharedSecret, namespaceName, className, asTypeName):
        self._oprot.writeMessageBegin('testNamespaceClassLoad', TMessageType.CALL, self._seqid)
        args = testNamespaceClassLoad_args()
        args.sharedSecret = sharedSecret
        args.namespaceName = namespaceName
        args.className = className
        args.asTypeName = asTypeName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_testNamespaceClassLoad(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = testNamespaceClassLoad_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch1 is not None:
            raise result.ouch1
        if result.ouch2 is not None:
            raise result.ouch2
        if result.ouch3 is not None:
            raise result.ouch3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "testNamespaceClassLoad failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["addConstraint"] = Processor.process_addConstraint
        self._processMap["addSplits"] = Processor.process_addSplits
        self._processMap["attachIterator"] = Processor.process_attachIterator
        self._processMap["checkIteratorConflicts"] = Processor.process_checkIteratorConflicts
        self._processMap["clearLocatorCache"] = Processor.process_clearLocatorCache
        self._processMap["cloneTable"] = Processor.process_cloneTable
        self._processMap["compactTable"] = Processor.process_compactTable
        self._processMap["cancelCompaction"] = Processor.process_cancelCompaction
        self._processMap["createTable"] = Processor.process_createTable
        self._processMap["deleteTable"] = Processor.process_deleteTable
        self._processMap["deleteRows"] = Processor.process_deleteRows
        self._processMap["exportTable"] = Processor.process_exportTable
        self._processMap["flushTable"] = Processor.process_flushTable
        self._processMap["getDiskUsage"] = Processor.process_getDiskUsage
        self._processMap["getLocalityGroups"] = Processor.process_getLocalityGroups
        self._processMap["getIteratorSetting"] = Processor.process_getIteratorSetting
        self._processMap["getMaxRow"] = Processor.process_getMaxRow
        self._processMap["getTableProperties"] = Processor.process_getTableProperties
        self._processMap["importDirectory"] = Processor.process_importDirectory
        self._processMap["importTable"] = Processor.process_importTable
        self._processMap["listSplits"] = Processor.process_listSplits
        self._processMap["listTables"] = Processor.process_listTables
        self._processMap["listIterators"] = Processor.process_listIterators
        self._processMap["listConstraints"] = Processor.process_listConstraints
        self._processMap["mergeTablets"] = Processor.process_mergeTablets
        self._processMap["offlineTable"] = Processor.process_offlineTable
        self._processMap["onlineTable"] = Processor.process_onlineTable
        self._processMap["removeConstraint"] = Processor.process_removeConstraint
        self._processMap["removeIterator"] = Processor.process_removeIterator
        self._processMap["removeTableProperty"] = Processor.process_removeTableProperty
        self._processMap["renameTable"] = Processor.process_renameTable
        self._processMap["setLocalityGroups"] = Processor.process_setLocalityGroups
        self._processMap["setTableProperty"] = Processor.process_setTableProperty
        self._processMap["splitRangeByTablets"] = Processor.process_splitRangeByTablets
        self._processMap["tableExists"] = Processor.process_tableExists
        self._processMap["tableIdMap"] = Processor.process_tableIdMap
        self._processMap["testTableClassLoad"] = Processor.process_testTableClassLoad
        self._processMap["pingTabletServer"] = Processor.process_pingTabletServer
        self._processMap["getActiveScans"] = Processor.process_getActiveScans
        self._processMap["getActiveCompactions"] = Processor.process_getActiveCompactions
        self._processMap["getSiteConfiguration"] = Processor.process_getSiteConfiguration
        self._processMap["getSystemConfiguration"] = Processor.process_getSystemConfiguration
        self._processMap["getTabletServers"] = Processor.process_getTabletServers
        self._processMap["removeProperty"] = Processor.process_removeProperty
        self._processMap["setProperty"] = Processor.process_setProperty
        self._processMap["testClassLoad"] = Processor.process_testClassLoad
        self._processMap["authenticateUser"] = Processor.process_authenticateUser
        self._processMap["changeUserAuthorizations"] = Processor.process_changeUserAuthorizations
        self._processMap["changeLocalUserPassword"] = Processor.process_changeLocalUserPassword
        self._processMap["createLocalUser"] = Processor.process_createLocalUser
        self._processMap["dropLocalUser"] = Processor.process_dropLocalUser
        self._processMap["getUserAuthorizations"] = Processor.process_getUserAuthorizations
        self._processMap["grantSystemPermission"] = Processor.process_grantSystemPermission
        self._processMap["grantTablePermission"] = Processor.process_grantTablePermission
        self._processMap["hasSystemPermission"] = Processor.process_hasSystemPermission
        self._processMap["hasTablePermission"] = Processor.process_hasTablePermission
        self._processMap["listLocalUsers"] = Processor.process_listLocalUsers
        self._processMap["revokeSystemPermission"] = Processor.process_revokeSystemPermission
        self._processMap["revokeTablePermission"] = Processor.process_revokeTablePermission
        self._processMap["grantNamespacePermission"] = Processor.process_grantNamespacePermission
        self._processMap["hasNamespacePermission"] = Processor.process_hasNamespacePermission
        self._processMap["revokeNamespacePermission"] = Processor.process_revokeNamespacePermission
        self._processMap["createBatchScanner"] = Processor.process_createBatchScanner
        self._processMap["createScanner"] = Processor.process_createScanner
        self._processMap["hasNext"] = Processor.process_hasNext
        self._processMap["nextEntry"] = Processor.process_nextEntry
        self._processMap["nextK"] = Processor.process_nextK
        self._processMap["closeScanner"] = Processor.process_closeScanner
        self._processMap["updateAndFlush"] = Processor.process_updateAndFlush
        self._processMap["createWriter"] = Processor.process_createWriter
        self._processMap["update"] = Processor.process_update
        self._processMap["flush"] = Processor.process_flush
        self._processMap["closeWriter"] = Processor.process_closeWriter
        self._processMap["updateRowConditionally"] = Processor.process_updateRowConditionally
        self._processMap["createConditionalWriter"] = Processor.process_createConditionalWriter
        self._processMap["updateRowsConditionally"] = Processor.process_updateRowsConditionally
        self._processMap["closeConditionalWriter"] = Processor.process_closeConditionalWriter
        self._processMap["getRowRange"] = Processor.process_getRowRange
        self._processMap["getFollowing"] = Processor.process_getFollowing
        self._processMap["systemNamespace"] = Processor.process_systemNamespace
        self._processMap["defaultNamespace"] = Processor.process_defaultNamespace
        self._processMap["listNamespaces"] = Processor.process_listNamespaces
        self._processMap["namespaceExists"] = Processor.process_namespaceExists
        self._processMap["createNamespace"] = Processor.process_createNamespace
        self._processMap["deleteNamespace"] = Processor.process_deleteNamespace
        self._processMap["renameNamespace"] = Processor.process_renameNamespace
        self._processMap["setNamespaceProperty"] = Processor.process_setNamespaceProperty
        self._processMap["removeNamespaceProperty"] = Processor.process_removeNamespaceProperty
        self._processMap["getNamespaceProperties"] = Processor.process_getNamespaceProperties
        self._processMap["namespaceIdMap"] = Processor.process_namespaceIdMap
        self._processMap["attachNamespaceIterator"] = Processor.process_attachNamespaceIterator
        self._processMap["removeNamespaceIterator"] = Processor.process_removeNamespaceIterator
        self._processMap["getNamespaceIteratorSetting"] = Processor.process_getNamespaceIteratorSetting
        self._processMap["listNamespaceIterators"] = Processor.process_listNamespaceIterators
        self._processMap["checkNamespaceIteratorConflicts"] = Processor.process_checkNamespaceIteratorConflicts
        self._processMap["addNamespaceConstraint"] = Processor.process_addNamespaceConstraint
        self._processMap["removeNamespaceConstraint"] = Processor.process_removeNamespaceConstraint
        self._processMap["listNamespaceConstraints"] = Processor.process_listNamespaceConstraints
        self._processMap["testNamespaceClassLoad"] = Processor.process_testNamespaceClassLoad
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_addConstraint(self, seqid, iprot, oprot):
        args = addConstraint_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = addConstraint_result()
        try:
            result.success = self._handler.addConstraint(args.sharedSecret, args.tableName, args.constraintClassName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TableNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("addConstraint", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_addSplits(self, seqid, iprot, oprot):
        args = addSplits_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = addSplits_result()
        try:
            self._handler.addSplits(args.sharedSecret, args.tableName, args.splits)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TableNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("addSplits", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_attachIterator(self, seqid, iprot, oprot):
        args = attachIterator_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = attachIterator_result()
        try:
            self._handler.attachIterator(args.sharedSecret, args.tableName, args.setting, args.scopes)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloSecurityException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TableNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("attachIterator", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_checkIteratorConflicts(self, seqid, iprot, oprot):
        args = checkIteratorConflicts_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = checkIteratorConflicts_result()
        try:
            self._handler.checkIteratorConflicts(args.sharedSecret, args.tableName, args.setting, args.scopes)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloSecurityException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TableNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("checkIteratorConflicts", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_clearLocatorCache(self, seqid, iprot, oprot):
        args = clearLocatorCache_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = clearLocatorCache_result()
        try:
            self._handler.clearLocatorCache(args.sharedSecret, args.tableName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TableNotFoundException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("clearLocatorCache", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_cloneTable(self, seqid, iprot, oprot):
        args = cloneTable_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = cloneTable_result()
        try:
            self._handler.cloneTable(args.sharedSecret, args.tableName, args.newTableName, args.flush, args.propertiesToSet, args.propertiesToExclude)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TableNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TableExistsException as ouch4:
            msg_type = TMessageType.REPLY
            result.ouch4 = ouch4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("cloneTable", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_compactTable(self, seqid, iprot, oprot):
        args = compactTable_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = compactTable_result()
        try:
            self._handler.compactTable(args.sharedSecret, args.tableName, args.startRow, args.endRow, args.iterators, args.flush, args.wait, args.selectorConfig, args.configurerConfig)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloSecurityException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except TableNotFoundException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except AccumuloException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("compactTable", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_cancelCompaction(self, seqid, iprot, oprot):
        args = cancelCompaction_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = cancelCompaction_result()
        try:
            self._handler.cancelCompaction(args.sharedSecret, args.tableName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloSecurityException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except TableNotFoundException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except AccumuloException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("cancelCompaction", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createTable(self, seqid, iprot, oprot):
        args = createTable_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createTable_result()
        try:
            self._handler.createTable(args.sharedSecret, args.tableName, args.versioningIter, args.type)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TableExistsException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createTable", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_deleteTable(self, seqid, iprot, oprot):
        args = deleteTable_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = deleteTable_result()
        try:
            self._handler.deleteTable(args.sharedSecret, args.tableName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TableNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("deleteTable", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_deleteRows(self, seqid, iprot, oprot):
        args = deleteRows_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = deleteRows_result()
        try:
            self._handler.deleteRows(args.sharedSecret, args.tableName, args.startRow, args.endRow)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TableNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("deleteRows", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_exportTable(self, seqid, iprot, oprot):
        args = exportTable_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = exportTable_result()
        try:
            self._handler.exportTable(args.sharedSecret, args.tableName, args.exportDir)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TableNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("exportTable", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_flushTable(self, seqid, iprot, oprot):
        args = flushTable_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = flushTable_result()
        try:
            self._handler.flushTable(args.sharedSecret, args.tableName, args.startRow, args.endRow, args.wait)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TableNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("flushTable", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDiskUsage(self, seqid, iprot, oprot):
        args = getDiskUsage_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDiskUsage_result()
        try:
            result.success = self._handler.getDiskUsage(args.sharedSecret, args.tables)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TableNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDiskUsage", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getLocalityGroups(self, seqid, iprot, oprot):
        args = getLocalityGroups_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getLocalityGroups_result()
        try:
            result.success = self._handler.getLocalityGroups(args.sharedSecret, args.tableName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TableNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getLocalityGroups", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getIteratorSetting(self, seqid, iprot, oprot):
        args = getIteratorSetting_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getIteratorSetting_result()
        try:
            result.success = self._handler.getIteratorSetting(args.sharedSecret, args.tableName, args.iteratorName, args.scope)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TableNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getIteratorSetting", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getMaxRow(self, seqid, iprot, oprot):
        args = getMaxRow_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getMaxRow_result()
        try:
            result.success = self._handler.getMaxRow(args.sharedSecret, args.tableName, args.auths, args.startRow, args.startInclusive, args.endRow, args.endInclusive)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TableNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getMaxRow", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getTableProperties(self, seqid, iprot, oprot):
        args = getTableProperties_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getTableProperties_result()
        try:
            result.success = self._handler.getTableProperties(args.sharedSecret, args.tableName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TableNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getTableProperties", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_importDirectory(self, seqid, iprot, oprot):
        args = importDirectory_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = importDirectory_result()
        try:
            self._handler.importDirectory(args.sharedSecret, args.tableName, args.importDir, args.failureDir, args.setTime)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TableNotFoundException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except AccumuloSecurityException as ouch4:
            msg_type = TMessageType.REPLY
            result.ouch4 = ouch4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("importDirectory", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_importTable(self, seqid, iprot, oprot):
        args = importTable_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = importTable_result()
        try:
            self._handler.importTable(args.sharedSecret, args.tableName, args.importDir)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TableExistsException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except AccumuloSecurityException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("importTable", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_listSplits(self, seqid, iprot, oprot):
        args = listSplits_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = listSplits_result()
        try:
            result.success = self._handler.listSplits(args.sharedSecret, args.tableName, args.maxSplits)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TableNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("listSplits", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_listTables(self, seqid, iprot, oprot):
        args = listTables_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = listTables_result()
        try:
            result.success = self._handler.listTables(args.sharedSecret)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("listTables", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_listIterators(self, seqid, iprot, oprot):
        args = listIterators_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = listIterators_result()
        try:
            result.success = self._handler.listIterators(args.sharedSecret, args.tableName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TableNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("listIterators", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_listConstraints(self, seqid, iprot, oprot):
        args = listConstraints_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = listConstraints_result()
        try:
            result.success = self._handler.listConstraints(args.sharedSecret, args.tableName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TableNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("listConstraints", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mergeTablets(self, seqid, iprot, oprot):
        args = mergeTablets_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mergeTablets_result()
        try:
            self._handler.mergeTablets(args.sharedSecret, args.tableName, args.startRow, args.endRow)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TableNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mergeTablets", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_offlineTable(self, seqid, iprot, oprot):
        args = offlineTable_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = offlineTable_result()
        try:
            self._handler.offlineTable(args.sharedSecret, args.tableName, args.wait)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TableNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("offlineTable", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_onlineTable(self, seqid, iprot, oprot):
        args = onlineTable_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = onlineTable_result()
        try:
            self._handler.onlineTable(args.sharedSecret, args.tableName, args.wait)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TableNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("onlineTable", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_removeConstraint(self, seqid, iprot, oprot):
        args = removeConstraint_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = removeConstraint_result()
        try:
            self._handler.removeConstraint(args.sharedSecret, args.tableName, args.constraint)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TableNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("removeConstraint", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_removeIterator(self, seqid, iprot, oprot):
        args = removeIterator_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = removeIterator_result()
        try:
            self._handler.removeIterator(args.sharedSecret, args.tableName, args.iterName, args.scopes)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TableNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("removeIterator", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_removeTableProperty(self, seqid, iprot, oprot):
        args = removeTableProperty_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = removeTableProperty_result()
        try:
            self._handler.removeTableProperty(args.sharedSecret, args.tableName, args.property)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TableNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("removeTableProperty", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_renameTable(self, seqid, iprot, oprot):
        args = renameTable_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = renameTable_result()
        try:
            self._handler.renameTable(args.sharedSecret, args.oldTableName, args.newTableName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TableNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TableExistsException as ouch4:
            msg_type = TMessageType.REPLY
            result.ouch4 = ouch4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("renameTable", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_setLocalityGroups(self, seqid, iprot, oprot):
        args = setLocalityGroups_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = setLocalityGroups_result()
        try:
            self._handler.setLocalityGroups(args.sharedSecret, args.tableName, args.groups)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TableNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("setLocalityGroups", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_setTableProperty(self, seqid, iprot, oprot):
        args = setTableProperty_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = setTableProperty_result()
        try:
            self._handler.setTableProperty(args.sharedSecret, args.tableName, args.property, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TableNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("setTableProperty", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_splitRangeByTablets(self, seqid, iprot, oprot):
        args = splitRangeByTablets_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = splitRangeByTablets_result()
        try:
            result.success = self._handler.splitRangeByTablets(args.sharedSecret, args.tableName, args.range, args.maxSplits)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TableNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("splitRangeByTablets", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_tableExists(self, seqid, iprot, oprot):
        args = tableExists_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = tableExists_result()
        try:
            result.success = self._handler.tableExists(args.sharedSecret, args.tableName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("tableExists", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_tableIdMap(self, seqid, iprot, oprot):
        args = tableIdMap_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = tableIdMap_result()
        try:
            result.success = self._handler.tableIdMap(args.sharedSecret)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("tableIdMap", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_testTableClassLoad(self, seqid, iprot, oprot):
        args = testTableClassLoad_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testTableClassLoad_result()
        try:
            result.success = self._handler.testTableClassLoad(args.sharedSecret, args.tableName, args.className, args.asTypeName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TableNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("testTableClassLoad", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pingTabletServer(self, seqid, iprot, oprot):
        args = pingTabletServer_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pingTabletServer_result()
        try:
            self._handler.pingTabletServer(args.sharedSecret, args.tserver)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pingTabletServer", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getActiveScans(self, seqid, iprot, oprot):
        args = getActiveScans_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getActiveScans_result()
        try:
            result.success = self._handler.getActiveScans(args.sharedSecret, args.tserver)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getActiveScans", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getActiveCompactions(self, seqid, iprot, oprot):
        args = getActiveCompactions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getActiveCompactions_result()
        try:
            result.success = self._handler.getActiveCompactions(args.sharedSecret, args.tserver)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getActiveCompactions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getSiteConfiguration(self, seqid, iprot, oprot):
        args = getSiteConfiguration_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getSiteConfiguration_result()
        try:
            result.success = self._handler.getSiteConfiguration(args.sharedSecret)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getSiteConfiguration", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getSystemConfiguration(self, seqid, iprot, oprot):
        args = getSystemConfiguration_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getSystemConfiguration_result()
        try:
            result.success = self._handler.getSystemConfiguration(args.sharedSecret)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getSystemConfiguration", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getTabletServers(self, seqid, iprot, oprot):
        args = getTabletServers_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getTabletServers_result()
        try:
            result.success = self._handler.getTabletServers(args.sharedSecret)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getTabletServers", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_removeProperty(self, seqid, iprot, oprot):
        args = removeProperty_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = removeProperty_result()
        try:
            self._handler.removeProperty(args.sharedSecret, args.property)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("removeProperty", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_setProperty(self, seqid, iprot, oprot):
        args = setProperty_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = setProperty_result()
        try:
            self._handler.setProperty(args.sharedSecret, args.property, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("setProperty", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_testClassLoad(self, seqid, iprot, oprot):
        args = testClassLoad_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testClassLoad_result()
        try:
            result.success = self._handler.testClassLoad(args.sharedSecret, args.className, args.asTypeName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("testClassLoad", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_authenticateUser(self, seqid, iprot, oprot):
        args = authenticateUser_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = authenticateUser_result()
        try:
            result.success = self._handler.authenticateUser(args.sharedSecret, args.user, args.properties)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("authenticateUser", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_changeUserAuthorizations(self, seqid, iprot, oprot):
        args = changeUserAuthorizations_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = changeUserAuthorizations_result()
        try:
            self._handler.changeUserAuthorizations(args.sharedSecret, args.user, args.authorizations)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("changeUserAuthorizations", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_changeLocalUserPassword(self, seqid, iprot, oprot):
        args = changeLocalUserPassword_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = changeLocalUserPassword_result()
        try:
            self._handler.changeLocalUserPassword(args.sharedSecret, args.user, args.password)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("changeLocalUserPassword", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createLocalUser(self, seqid, iprot, oprot):
        args = createLocalUser_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createLocalUser_result()
        try:
            self._handler.createLocalUser(args.sharedSecret, args.user, args.password)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createLocalUser", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_dropLocalUser(self, seqid, iprot, oprot):
        args = dropLocalUser_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = dropLocalUser_result()
        try:
            self._handler.dropLocalUser(args.sharedSecret, args.user)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("dropLocalUser", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getUserAuthorizations(self, seqid, iprot, oprot):
        args = getUserAuthorizations_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getUserAuthorizations_result()
        try:
            result.success = self._handler.getUserAuthorizations(args.sharedSecret, args.user)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getUserAuthorizations", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_grantSystemPermission(self, seqid, iprot, oprot):
        args = grantSystemPermission_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = grantSystemPermission_result()
        try:
            self._handler.grantSystemPermission(args.sharedSecret, args.user, args.perm)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("grantSystemPermission", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_grantTablePermission(self, seqid, iprot, oprot):
        args = grantTablePermission_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = grantTablePermission_result()
        try:
            self._handler.grantTablePermission(args.sharedSecret, args.user, args.table, args.perm)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TableNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("grantTablePermission", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_hasSystemPermission(self, seqid, iprot, oprot):
        args = hasSystemPermission_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = hasSystemPermission_result()
        try:
            result.success = self._handler.hasSystemPermission(args.sharedSecret, args.user, args.perm)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("hasSystemPermission", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_hasTablePermission(self, seqid, iprot, oprot):
        args = hasTablePermission_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = hasTablePermission_result()
        try:
            result.success = self._handler.hasTablePermission(args.sharedSecret, args.user, args.table, args.perm)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TableNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("hasTablePermission", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_listLocalUsers(self, seqid, iprot, oprot):
        args = listLocalUsers_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = listLocalUsers_result()
        try:
            result.success = self._handler.listLocalUsers(args.sharedSecret)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TableNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("listLocalUsers", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_revokeSystemPermission(self, seqid, iprot, oprot):
        args = revokeSystemPermission_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = revokeSystemPermission_result()
        try:
            self._handler.revokeSystemPermission(args.sharedSecret, args.user, args.perm)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("revokeSystemPermission", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_revokeTablePermission(self, seqid, iprot, oprot):
        args = revokeTablePermission_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = revokeTablePermission_result()
        try:
            self._handler.revokeTablePermission(args.sharedSecret, args.user, args.table, args.perm)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TableNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("revokeTablePermission", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_grantNamespacePermission(self, seqid, iprot, oprot):
        args = grantNamespacePermission_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = grantNamespacePermission_result()
        try:
            self._handler.grantNamespacePermission(args.sharedSecret, args.user, args.namespaceName, args.perm)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("grantNamespacePermission", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_hasNamespacePermission(self, seqid, iprot, oprot):
        args = hasNamespacePermission_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = hasNamespacePermission_result()
        try:
            result.success = self._handler.hasNamespacePermission(args.sharedSecret, args.user, args.namespaceName, args.perm)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("hasNamespacePermission", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_revokeNamespacePermission(self, seqid, iprot, oprot):
        args = revokeNamespacePermission_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = revokeNamespacePermission_result()
        try:
            self._handler.revokeNamespacePermission(args.sharedSecret, args.user, args.namespaceName, args.perm)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("revokeNamespacePermission", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createBatchScanner(self, seqid, iprot, oprot):
        args = createBatchScanner_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createBatchScanner_result()
        try:
            result.success = self._handler.createBatchScanner(args.sharedSecret, args.tableName, args.options)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TableNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createBatchScanner", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createScanner(self, seqid, iprot, oprot):
        args = createScanner_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createScanner_result()
        try:
            result.success = self._handler.createScanner(args.sharedSecret, args.tableName, args.options)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TableNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createScanner", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_hasNext(self, seqid, iprot, oprot):
        args = hasNext_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = hasNext_result()
        try:
            result.success = self._handler.hasNext(args.scanner)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except UnknownScanner as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("hasNext", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_nextEntry(self, seqid, iprot, oprot):
        args = nextEntry_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = nextEntry_result()
        try:
            result.success = self._handler.nextEntry(args.scanner)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoMoreEntriesException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except UnknownScanner as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except AccumuloSecurityException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("nextEntry", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_nextK(self, seqid, iprot, oprot):
        args = nextK_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = nextK_result()
        try:
            result.success = self._handler.nextK(args.scanner, args.k)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NoMoreEntriesException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except UnknownScanner as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except AccumuloSecurityException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("nextK", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_closeScanner(self, seqid, iprot, oprot):
        args = closeScanner_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = closeScanner_result()
        try:
            self._handler.closeScanner(args.scanner)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except UnknownScanner as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("closeScanner", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateAndFlush(self, seqid, iprot, oprot):
        args = updateAndFlush_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateAndFlush_result()
        try:
            self._handler.updateAndFlush(args.sharedSecret, args.tableName, args.cells)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as outch1:
            msg_type = TMessageType.REPLY
            result.outch1 = outch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TableNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except MutationsRejectedException as ouch4:
            msg_type = TMessageType.REPLY
            result.ouch4 = ouch4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updateAndFlush", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createWriter(self, seqid, iprot, oprot):
        args = createWriter_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createWriter_result()
        try:
            result.success = self._handler.createWriter(args.sharedSecret, args.tableName, args.opts)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as outch1:
            msg_type = TMessageType.REPLY
            result.outch1 = outch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TableNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createWriter", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_update(self, seqid, iprot, oprot):
        args = update_args()
        args.read(iprot)
        iprot.readMessageEnd()
        try:
            self._handler.update(args.writer, args.cells)
        except TTransport.TTransportException:
            raise
        except Exception:
            logging.exception('Exception in oneway handler')

    def process_flush(self, seqid, iprot, oprot):
        args = flush_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = flush_result()
        try:
            self._handler.flush(args.writer)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except UnknownWriter as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except MutationsRejectedException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("flush", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_closeWriter(self, seqid, iprot, oprot):
        args = closeWriter_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = closeWriter_result()
        try:
            self._handler.closeWriter(args.writer)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except UnknownWriter as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except MutationsRejectedException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("closeWriter", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateRowConditionally(self, seqid, iprot, oprot):
        args = updateRowConditionally_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateRowConditionally_result()
        try:
            result.success = self._handler.updateRowConditionally(args.sharedSecret, args.tableName, args.row, args.updates)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TableNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updateRowConditionally", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createConditionalWriter(self, seqid, iprot, oprot):
        args = createConditionalWriter_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createConditionalWriter_result()
        try:
            result.success = self._handler.createConditionalWriter(args.sharedSecret, args.tableName, args.options)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TableNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createConditionalWriter", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateRowsConditionally(self, seqid, iprot, oprot):
        args = updateRowsConditionally_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateRowsConditionally_result()
        try:
            result.success = self._handler.updateRowsConditionally(args.conditionalWriter, args.updates)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except UnknownWriter as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except AccumuloSecurityException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updateRowsConditionally", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_closeConditionalWriter(self, seqid, iprot, oprot):
        args = closeConditionalWriter_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = closeConditionalWriter_result()
        try:
            self._handler.closeConditionalWriter(args.conditionalWriter)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("closeConditionalWriter", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getRowRange(self, seqid, iprot, oprot):
        args = getRowRange_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getRowRange_result()
        try:
            result.success = self._handler.getRowRange(args.row)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getRowRange", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getFollowing(self, seqid, iprot, oprot):
        args = getFollowing_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getFollowing_result()
        try:
            result.success = self._handler.getFollowing(args.key, args.part)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getFollowing", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_systemNamespace(self, seqid, iprot, oprot):
        args = systemNamespace_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = systemNamespace_result()
        try:
            result.success = self._handler.systemNamespace()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("systemNamespace", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_defaultNamespace(self, seqid, iprot, oprot):
        args = defaultNamespace_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = defaultNamespace_result()
        try:
            result.success = self._handler.defaultNamespace()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("defaultNamespace", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_listNamespaces(self, seqid, iprot, oprot):
        args = listNamespaces_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = listNamespaces_result()
        try:
            result.success = self._handler.listNamespaces(args.sharedSecret)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("listNamespaces", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_namespaceExists(self, seqid, iprot, oprot):
        args = namespaceExists_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = namespaceExists_result()
        try:
            result.success = self._handler.namespaceExists(args.sharedSecret, args.namespaceName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("namespaceExists", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createNamespace(self, seqid, iprot, oprot):
        args = createNamespace_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createNamespace_result()
        try:
            self._handler.createNamespace(args.sharedSecret, args.namespaceName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except NamespaceExistsException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createNamespace", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_deleteNamespace(self, seqid, iprot, oprot):
        args = deleteNamespace_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = deleteNamespace_result()
        try:
            self._handler.deleteNamespace(args.sharedSecret, args.namespaceName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except NamespaceNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except NamespaceNotEmptyException as ouch4:
            msg_type = TMessageType.REPLY
            result.ouch4 = ouch4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("deleteNamespace", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_renameNamespace(self, seqid, iprot, oprot):
        args = renameNamespace_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = renameNamespace_result()
        try:
            self._handler.renameNamespace(args.sharedSecret, args.oldNamespaceName, args.newNamespaceName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except NamespaceNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except NamespaceExistsException as ouch4:
            msg_type = TMessageType.REPLY
            result.ouch4 = ouch4
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("renameNamespace", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_setNamespaceProperty(self, seqid, iprot, oprot):
        args = setNamespaceProperty_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = setNamespaceProperty_result()
        try:
            self._handler.setNamespaceProperty(args.sharedSecret, args.namespaceName, args.property, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except NamespaceNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("setNamespaceProperty", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_removeNamespaceProperty(self, seqid, iprot, oprot):
        args = removeNamespaceProperty_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = removeNamespaceProperty_result()
        try:
            self._handler.removeNamespaceProperty(args.sharedSecret, args.namespaceName, args.property)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except NamespaceNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("removeNamespaceProperty", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getNamespaceProperties(self, seqid, iprot, oprot):
        args = getNamespaceProperties_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getNamespaceProperties_result()
        try:
            result.success = self._handler.getNamespaceProperties(args.sharedSecret, args.namespaceName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except NamespaceNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getNamespaceProperties", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_namespaceIdMap(self, seqid, iprot, oprot):
        args = namespaceIdMap_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = namespaceIdMap_result()
        try:
            result.success = self._handler.namespaceIdMap(args.sharedSecret)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("namespaceIdMap", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_attachNamespaceIterator(self, seqid, iprot, oprot):
        args = attachNamespaceIterator_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = attachNamespaceIterator_result()
        try:
            self._handler.attachNamespaceIterator(args.sharedSecret, args.namespaceName, args.setting, args.scopes)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except NamespaceNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("attachNamespaceIterator", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_removeNamespaceIterator(self, seqid, iprot, oprot):
        args = removeNamespaceIterator_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = removeNamespaceIterator_result()
        try:
            self._handler.removeNamespaceIterator(args.sharedSecret, args.namespaceName, args.name, args.scopes)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except NamespaceNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("removeNamespaceIterator", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getNamespaceIteratorSetting(self, seqid, iprot, oprot):
        args = getNamespaceIteratorSetting_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getNamespaceIteratorSetting_result()
        try:
            result.success = self._handler.getNamespaceIteratorSetting(args.sharedSecret, args.namespaceName, args.name, args.scope)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except NamespaceNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getNamespaceIteratorSetting", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_listNamespaceIterators(self, seqid, iprot, oprot):
        args = listNamespaceIterators_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = listNamespaceIterators_result()
        try:
            result.success = self._handler.listNamespaceIterators(args.sharedSecret, args.namespaceName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except NamespaceNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("listNamespaceIterators", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_checkNamespaceIteratorConflicts(self, seqid, iprot, oprot):
        args = checkNamespaceIteratorConflicts_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = checkNamespaceIteratorConflicts_result()
        try:
            self._handler.checkNamespaceIteratorConflicts(args.sharedSecret, args.namespaceName, args.setting, args.scopes)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except NamespaceNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("checkNamespaceIteratorConflicts", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_addNamespaceConstraint(self, seqid, iprot, oprot):
        args = addNamespaceConstraint_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = addNamespaceConstraint_result()
        try:
            result.success = self._handler.addNamespaceConstraint(args.sharedSecret, args.namespaceName, args.constraintClassName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except NamespaceNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("addNamespaceConstraint", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_removeNamespaceConstraint(self, seqid, iprot, oprot):
        args = removeNamespaceConstraint_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = removeNamespaceConstraint_result()
        try:
            self._handler.removeNamespaceConstraint(args.sharedSecret, args.namespaceName, args.id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except NamespaceNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("removeNamespaceConstraint", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_listNamespaceConstraints(self, seqid, iprot, oprot):
        args = listNamespaceConstraints_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = listNamespaceConstraints_result()
        try:
            result.success = self._handler.listNamespaceConstraints(args.sharedSecret, args.namespaceName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except NamespaceNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("listNamespaceConstraints", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_testNamespaceClassLoad(self, seqid, iprot, oprot):
        args = testNamespaceClassLoad_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testNamespaceClassLoad_result()
        try:
            result.success = self._handler.testNamespaceClassLoad(args.sharedSecret, args.namespaceName, args.className, args.asTypeName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except AccumuloException as ouch1:
            msg_type = TMessageType.REPLY
            result.ouch1 = ouch1
        except AccumuloSecurityException as ouch2:
            msg_type = TMessageType.REPLY
            result.ouch2 = ouch2
        except NamespaceNotFoundException as ouch3:
            msg_type = TMessageType.REPLY
            result.ouch3 = ouch3
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("testNamespaceClassLoad", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class addConstraint_args(object):
    """
    Attributes:
     - sharedSecret
     - tableName
     - constraintClassName

    """


    def __init__(self, sharedSecret=None, tableName=None, constraintClassName=None,):
        self.sharedSecret = sharedSecret
        self.tableName = tableName
        self.constraintClassName = constraintClassName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.constraintClassName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('addConstraint_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.constraintClassName is not None:
            oprot.writeFieldBegin('constraintClassName', TType.STRING, 3)
            oprot.writeString(self.constraintClassName.encode('utf-8') if sys.version_info[0] == 2 else self.constraintClassName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(addConstraint_args)
addConstraint_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'constraintClassName', 'UTF8', None, ),  # 3
)


class addConstraint_result(object):
    """
    Attributes:
     - success
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
        self.success = success
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = TableNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('addConstraint_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(addConstraint_result)
addConstraint_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [TableNotFoundException, None], None, ),  # 3
)


class addSplits_args(object):
    """
    Attributes:
     - sharedSecret
     - tableName
     - splits

    """


    def __init__(self, sharedSecret=None, tableName=None, splits=None,):
        self.sharedSecret = sharedSecret
        self.tableName = tableName
        self.splits = splits

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.SET:
                    self.splits = set()
                    (_etype147, _size144) = iprot.readSetBegin()
                    for _i148 in range(_size144):
                        _elem149 = iprot.readBinary()
                        self.splits.add(_elem149)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('addSplits_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.splits is not None:
            oprot.writeFieldBegin('splits', TType.SET, 3)
            oprot.writeSetBegin(TType.STRING, len(self.splits))
            for iter150 in self.splits:
                oprot.writeBinary(iter150)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(addSplits_args)
addSplits_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
    (3, TType.SET, 'splits', (TType.STRING, 'BINARY', False), None, ),  # 3
)


class addSplits_result(object):
    """
    Attributes:
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = TableNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('addSplits_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(addSplits_result)
addSplits_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [TableNotFoundException, None], None, ),  # 3
)


class attachIterator_args(object):
    """
    Attributes:
     - sharedSecret
     - tableName
     - setting
     - scopes

    """


    def __init__(self, sharedSecret=None, tableName=None, setting=None, scopes=None,):
        self.sharedSecret = sharedSecret
        self.tableName = tableName
        self.setting = setting
        self.scopes = scopes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.setting = IteratorSetting()
                    self.setting.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.SET:
                    self.scopes = set()
                    (_etype154, _size151) = iprot.readSetBegin()
                    for _i155 in range(_size151):
                        _elem156 = iprot.readI32()
                        self.scopes.add(_elem156)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('attachIterator_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.setting is not None:
            oprot.writeFieldBegin('setting', TType.STRUCT, 3)
            self.setting.write(oprot)
            oprot.writeFieldEnd()
        if self.scopes is not None:
            oprot.writeFieldBegin('scopes', TType.SET, 4)
            oprot.writeSetBegin(TType.I32, len(self.scopes))
            for iter157 in self.scopes:
                oprot.writeI32(iter157)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(attachIterator_args)
attachIterator_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'setting', [IteratorSetting, None], None, ),  # 3
    (4, TType.SET, 'scopes', (TType.I32, None, False), None, ),  # 4
)


class attachIterator_result(object):
    """
    Attributes:
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = TableNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('attachIterator_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(attachIterator_result)
attachIterator_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloSecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [TableNotFoundException, None], None, ),  # 3
)


class checkIteratorConflicts_args(object):
    """
    Attributes:
     - sharedSecret
     - tableName
     - setting
     - scopes

    """


    def __init__(self, sharedSecret=None, tableName=None, setting=None, scopes=None,):
        self.sharedSecret = sharedSecret
        self.tableName = tableName
        self.setting = setting
        self.scopes = scopes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.setting = IteratorSetting()
                    self.setting.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.SET:
                    self.scopes = set()
                    (_etype161, _size158) = iprot.readSetBegin()
                    for _i162 in range(_size158):
                        _elem163 = iprot.readI32()
                        self.scopes.add(_elem163)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('checkIteratorConflicts_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.setting is not None:
            oprot.writeFieldBegin('setting', TType.STRUCT, 3)
            self.setting.write(oprot)
            oprot.writeFieldEnd()
        if self.scopes is not None:
            oprot.writeFieldBegin('scopes', TType.SET, 4)
            oprot.writeSetBegin(TType.I32, len(self.scopes))
            for iter164 in self.scopes:
                oprot.writeI32(iter164)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(checkIteratorConflicts_args)
checkIteratorConflicts_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'setting', [IteratorSetting, None], None, ),  # 3
    (4, TType.SET, 'scopes', (TType.I32, None, False), None, ),  # 4
)


class checkIteratorConflicts_result(object):
    """
    Attributes:
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = TableNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('checkIteratorConflicts_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(checkIteratorConflicts_result)
checkIteratorConflicts_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloSecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [TableNotFoundException, None], None, ),  # 3
)


class clearLocatorCache_args(object):
    """
    Attributes:
     - sharedSecret
     - tableName

    """


    def __init__(self, sharedSecret=None, tableName=None,):
        self.sharedSecret = sharedSecret
        self.tableName = tableName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('clearLocatorCache_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(clearLocatorCache_args)
clearLocatorCache_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
)


class clearLocatorCache_result(object):
    """
    Attributes:
     - ouch1

    """


    def __init__(self, ouch1=None,):
        self.ouch1 = ouch1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = TableNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('clearLocatorCache_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(clearLocatorCache_result)
clearLocatorCache_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [TableNotFoundException, None], None, ),  # 1
)


class cloneTable_args(object):
    """
    Attributes:
     - sharedSecret
     - tableName
     - newTableName
     - flush
     - propertiesToSet
     - propertiesToExclude

    """


    def __init__(self, sharedSecret=None, tableName=None, newTableName=None, flush=None, propertiesToSet=None, propertiesToExclude=None,):
        self.sharedSecret = sharedSecret
        self.tableName = tableName
        self.newTableName = newTableName
        self.flush = flush
        self.propertiesToSet = propertiesToSet
        self.propertiesToExclude = propertiesToExclude

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.newTableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.flush = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.MAP:
                    self.propertiesToSet = {}
                    (_ktype166, _vtype167, _size165) = iprot.readMapBegin()
                    for _i169 in range(_size165):
                        _key170 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val171 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.propertiesToSet[_key170] = _val171
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.SET:
                    self.propertiesToExclude = set()
                    (_etype175, _size172) = iprot.readSetBegin()
                    for _i176 in range(_size172):
                        _elem177 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.propertiesToExclude.add(_elem177)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('cloneTable_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.newTableName is not None:
            oprot.writeFieldBegin('newTableName', TType.STRING, 3)
            oprot.writeString(self.newTableName.encode('utf-8') if sys.version_info[0] == 2 else self.newTableName)
            oprot.writeFieldEnd()
        if self.flush is not None:
            oprot.writeFieldBegin('flush', TType.BOOL, 4)
            oprot.writeBool(self.flush)
            oprot.writeFieldEnd()
        if self.propertiesToSet is not None:
            oprot.writeFieldBegin('propertiesToSet', TType.MAP, 5)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.propertiesToSet))
            for kiter178, viter179 in self.propertiesToSet.items():
                oprot.writeString(kiter178.encode('utf-8') if sys.version_info[0] == 2 else kiter178)
                oprot.writeString(viter179.encode('utf-8') if sys.version_info[0] == 2 else viter179)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.propertiesToExclude is not None:
            oprot.writeFieldBegin('propertiesToExclude', TType.SET, 6)
            oprot.writeSetBegin(TType.STRING, len(self.propertiesToExclude))
            for iter180 in self.propertiesToExclude:
                oprot.writeString(iter180.encode('utf-8') if sys.version_info[0] == 2 else iter180)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(cloneTable_args)
cloneTable_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'newTableName', 'UTF8', None, ),  # 3
    (4, TType.BOOL, 'flush', None, None, ),  # 4
    (5, TType.MAP, 'propertiesToSet', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 5
    (6, TType.SET, 'propertiesToExclude', (TType.STRING, 'UTF8', False), None, ),  # 6
)


class cloneTable_result(object):
    """
    Attributes:
     - ouch1
     - ouch2
     - ouch3
     - ouch4

    """


    def __init__(self, ouch1=None, ouch2=None, ouch3=None, ouch4=None,):
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3
        self.ouch4 = ouch4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = TableNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ouch4 = TableExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('cloneTable_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch4 is not None:
            oprot.writeFieldBegin('ouch4', TType.STRUCT, 4)
            self.ouch4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(cloneTable_result)
cloneTable_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [TableNotFoundException, None], None, ),  # 3
    (4, TType.STRUCT, 'ouch4', [TableExistsException, None], None, ),  # 4
)


class compactTable_args(object):
    """
    Attributes:
     - sharedSecret
     - tableName
     - startRow
     - endRow
     - iterators
     - flush
     - wait
     - selectorConfig
     - configurerConfig

    """


    def __init__(self, sharedSecret=None, tableName=None, startRow=None, endRow=None, iterators=None, flush=None, wait=None, selectorConfig=None, configurerConfig=None,):
        self.sharedSecret = sharedSecret
        self.tableName = tableName
        self.startRow = startRow
        self.endRow = endRow
        self.iterators = iterators
        self.flush = flush
        self.wait = wait
        self.selectorConfig = selectorConfig
        self.configurerConfig = configurerConfig

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.startRow = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.endRow = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.iterators = []
                    (_etype184, _size181) = iprot.readListBegin()
                    for _i185 in range(_size181):
                        _elem186 = IteratorSetting()
                        _elem186.read(iprot)
                        self.iterators.append(_elem186)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.flush = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.wait = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.selectorConfig = PluginConfig()
                    self.selectorConfig.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRUCT:
                    self.configurerConfig = PluginConfig()
                    self.configurerConfig.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('compactTable_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.startRow is not None:
            oprot.writeFieldBegin('startRow', TType.STRING, 3)
            oprot.writeBinary(self.startRow)
            oprot.writeFieldEnd()
        if self.endRow is not None:
            oprot.writeFieldBegin('endRow', TType.STRING, 4)
            oprot.writeBinary(self.endRow)
            oprot.writeFieldEnd()
        if self.iterators is not None:
            oprot.writeFieldBegin('iterators', TType.LIST, 5)
            oprot.writeListBegin(TType.STRUCT, len(self.iterators))
            for iter187 in self.iterators:
                iter187.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.flush is not None:
            oprot.writeFieldBegin('flush', TType.BOOL, 6)
            oprot.writeBool(self.flush)
            oprot.writeFieldEnd()
        if self.wait is not None:
            oprot.writeFieldBegin('wait', TType.BOOL, 7)
            oprot.writeBool(self.wait)
            oprot.writeFieldEnd()
        if self.selectorConfig is not None:
            oprot.writeFieldBegin('selectorConfig', TType.STRUCT, 8)
            self.selectorConfig.write(oprot)
            oprot.writeFieldEnd()
        if self.configurerConfig is not None:
            oprot.writeFieldBegin('configurerConfig', TType.STRUCT, 9)
            self.configurerConfig.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(compactTable_args)
compactTable_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'startRow', 'BINARY', None, ),  # 3
    (4, TType.STRING, 'endRow', 'BINARY', None, ),  # 4
    (5, TType.LIST, 'iterators', (TType.STRUCT, [IteratorSetting, None], False), None, ),  # 5
    (6, TType.BOOL, 'flush', None, None, ),  # 6
    (7, TType.BOOL, 'wait', None, None, ),  # 7
    (8, TType.STRUCT, 'selectorConfig', [PluginConfig, None], None, ),  # 8
    (9, TType.STRUCT, 'configurerConfig', [PluginConfig, None], None, ),  # 9
)


class compactTable_result(object):
    """
    Attributes:
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = TableNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('compactTable_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(compactTable_result)
compactTable_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloSecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [TableNotFoundException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [AccumuloException, None], None, ),  # 3
)


class cancelCompaction_args(object):
    """
    Attributes:
     - sharedSecret
     - tableName

    """


    def __init__(self, sharedSecret=None, tableName=None,):
        self.sharedSecret = sharedSecret
        self.tableName = tableName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('cancelCompaction_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(cancelCompaction_args)
cancelCompaction_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
)


class cancelCompaction_result(object):
    """
    Attributes:
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = TableNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('cancelCompaction_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(cancelCompaction_result)
cancelCompaction_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloSecurityException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [TableNotFoundException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [AccumuloException, None], None, ),  # 3
)


class createTable_args(object):
    """
    Attributes:
     - sharedSecret
     - tableName
     - versioningIter
     - type

    """


    def __init__(self, sharedSecret=None, tableName=None, versioningIter=None, type=None,):
        self.sharedSecret = sharedSecret
        self.tableName = tableName
        self.versioningIter = versioningIter
        self.type = type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.versioningIter = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createTable_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.versioningIter is not None:
            oprot.writeFieldBegin('versioningIter', TType.BOOL, 3)
            oprot.writeBool(self.versioningIter)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 4)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createTable_args)
createTable_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'versioningIter', None, None, ),  # 3
    (4, TType.I32, 'type', None, None, ),  # 4
)


class createTable_result(object):
    """
    Attributes:
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = TableExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createTable_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createTable_result)
createTable_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [TableExistsException, None], None, ),  # 3
)


class deleteTable_args(object):
    """
    Attributes:
     - sharedSecret
     - tableName

    """


    def __init__(self, sharedSecret=None, tableName=None,):
        self.sharedSecret = sharedSecret
        self.tableName = tableName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deleteTable_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deleteTable_args)
deleteTable_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
)


class deleteTable_result(object):
    """
    Attributes:
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = TableNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deleteTable_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deleteTable_result)
deleteTable_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [TableNotFoundException, None], None, ),  # 3
)


class deleteRows_args(object):
    """
    Attributes:
     - sharedSecret
     - tableName
     - startRow
     - endRow

    """


    def __init__(self, sharedSecret=None, tableName=None, startRow=None, endRow=None,):
        self.sharedSecret = sharedSecret
        self.tableName = tableName
        self.startRow = startRow
        self.endRow = endRow

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.startRow = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.endRow = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deleteRows_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.startRow is not None:
            oprot.writeFieldBegin('startRow', TType.STRING, 3)
            oprot.writeBinary(self.startRow)
            oprot.writeFieldEnd()
        if self.endRow is not None:
            oprot.writeFieldBegin('endRow', TType.STRING, 4)
            oprot.writeBinary(self.endRow)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deleteRows_args)
deleteRows_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'startRow', 'BINARY', None, ),  # 3
    (4, TType.STRING, 'endRow', 'BINARY', None, ),  # 4
)


class deleteRows_result(object):
    """
    Attributes:
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = TableNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deleteRows_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deleteRows_result)
deleteRows_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [TableNotFoundException, None], None, ),  # 3
)


class exportTable_args(object):
    """
    Attributes:
     - sharedSecret
     - tableName
     - exportDir

    """


    def __init__(self, sharedSecret=None, tableName=None, exportDir=None,):
        self.sharedSecret = sharedSecret
        self.tableName = tableName
        self.exportDir = exportDir

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.exportDir = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('exportTable_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.exportDir is not None:
            oprot.writeFieldBegin('exportDir', TType.STRING, 3)
            oprot.writeString(self.exportDir.encode('utf-8') if sys.version_info[0] == 2 else self.exportDir)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(exportTable_args)
exportTable_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'exportDir', 'UTF8', None, ),  # 3
)


class exportTable_result(object):
    """
    Attributes:
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = TableNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('exportTable_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(exportTable_result)
exportTable_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [TableNotFoundException, None], None, ),  # 3
)


class flushTable_args(object):
    """
    Attributes:
     - sharedSecret
     - tableName
     - startRow
     - endRow
     - wait

    """


    def __init__(self, sharedSecret=None, tableName=None, startRow=None, endRow=None, wait=None,):
        self.sharedSecret = sharedSecret
        self.tableName = tableName
        self.startRow = startRow
        self.endRow = endRow
        self.wait = wait

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.startRow = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.endRow = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.wait = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('flushTable_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.startRow is not None:
            oprot.writeFieldBegin('startRow', TType.STRING, 3)
            oprot.writeBinary(self.startRow)
            oprot.writeFieldEnd()
        if self.endRow is not None:
            oprot.writeFieldBegin('endRow', TType.STRING, 4)
            oprot.writeBinary(self.endRow)
            oprot.writeFieldEnd()
        if self.wait is not None:
            oprot.writeFieldBegin('wait', TType.BOOL, 5)
            oprot.writeBool(self.wait)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(flushTable_args)
flushTable_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'startRow', 'BINARY', None, ),  # 3
    (4, TType.STRING, 'endRow', 'BINARY', None, ),  # 4
    (5, TType.BOOL, 'wait', None, None, ),  # 5
)


class flushTable_result(object):
    """
    Attributes:
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = TableNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('flushTable_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(flushTable_result)
flushTable_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [TableNotFoundException, None], None, ),  # 3
)


class getDiskUsage_args(object):
    """
    Attributes:
     - sharedSecret
     - tables

    """


    def __init__(self, sharedSecret=None, tables=None,):
        self.sharedSecret = sharedSecret
        self.tables = tables

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.SET:
                    self.tables = set()
                    (_etype191, _size188) = iprot.readSetBegin()
                    for _i192 in range(_size188):
                        _elem193 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.tables.add(_elem193)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDiskUsage_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.tables is not None:
            oprot.writeFieldBegin('tables', TType.SET, 2)
            oprot.writeSetBegin(TType.STRING, len(self.tables))
            for iter194 in self.tables:
                oprot.writeString(iter194.encode('utf-8') if sys.version_info[0] == 2 else iter194)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDiskUsage_args)
getDiskUsage_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.SET, 'tables', (TType.STRING, 'UTF8', False), None, ),  # 2
)


class getDiskUsage_result(object):
    """
    Attributes:
     - success
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
        self.success = success
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype198, _size195) = iprot.readListBegin()
                    for _i199 in range(_size195):
                        _elem200 = DiskUsage()
                        _elem200.read(iprot)
                        self.success.append(_elem200)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = TableNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDiskUsage_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter201 in self.success:
                iter201.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDiskUsage_result)
getDiskUsage_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [DiskUsage, None], False), None, ),  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [TableNotFoundException, None], None, ),  # 3
)


class getLocalityGroups_args(object):
    """
    Attributes:
     - sharedSecret
     - tableName

    """


    def __init__(self, sharedSecret=None, tableName=None,):
        self.sharedSecret = sharedSecret
        self.tableName = tableName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getLocalityGroups_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getLocalityGroups_args)
getLocalityGroups_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
)


class getLocalityGroups_result(object):
    """
    Attributes:
     - success
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
        self.success = success
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype203, _vtype204, _size202) = iprot.readMapBegin()
                    for _i206 in range(_size202):
                        _key207 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val208 = set()
                        (_etype212, _size209) = iprot.readSetBegin()
                        for _i213 in range(_size209):
                            _elem214 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val208.add(_elem214)
                        iprot.readSetEnd()
                        self.success[_key207] = _val208
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = TableNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getLocalityGroups_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.SET, len(self.success))
            for kiter215, viter216 in self.success.items():
                oprot.writeString(kiter215.encode('utf-8') if sys.version_info[0] == 2 else kiter215)
                oprot.writeSetBegin(TType.STRING, len(viter216))
                for iter217 in viter216:
                    oprot.writeString(iter217.encode('utf-8') if sys.version_info[0] == 2 else iter217)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getLocalityGroups_result)
getLocalityGroups_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.SET, (TType.STRING, 'UTF8', False), False), None, ),  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [TableNotFoundException, None], None, ),  # 3
)


class getIteratorSetting_args(object):
    """
    Attributes:
     - sharedSecret
     - tableName
     - iteratorName
     - scope

    """


    def __init__(self, sharedSecret=None, tableName=None, iteratorName=None, scope=None,):
        self.sharedSecret = sharedSecret
        self.tableName = tableName
        self.iteratorName = iteratorName
        self.scope = scope

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.iteratorName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.scope = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getIteratorSetting_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.iteratorName is not None:
            oprot.writeFieldBegin('iteratorName', TType.STRING, 3)
            oprot.writeString(self.iteratorName.encode('utf-8') if sys.version_info[0] == 2 else self.iteratorName)
            oprot.writeFieldEnd()
        if self.scope is not None:
            oprot.writeFieldBegin('scope', TType.I32, 4)
            oprot.writeI32(self.scope)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getIteratorSetting_args)
getIteratorSetting_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'iteratorName', 'UTF8', None, ),  # 3
    (4, TType.I32, 'scope', None, None, ),  # 4
)


class getIteratorSetting_result(object):
    """
    Attributes:
     - success
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
        self.success = success
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = IteratorSetting()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = TableNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getIteratorSetting_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getIteratorSetting_result)
getIteratorSetting_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [IteratorSetting, None], None, ),  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [TableNotFoundException, None], None, ),  # 3
)


class getMaxRow_args(object):
    """
    Attributes:
     - sharedSecret
     - tableName
     - auths
     - startRow
     - startInclusive
     - endRow
     - endInclusive

    """


    def __init__(self, sharedSecret=None, tableName=None, auths=None, startRow=None, startInclusive=None, endRow=None, endInclusive=None,):
        self.sharedSecret = sharedSecret
        self.tableName = tableName
        self.auths = auths
        self.startRow = startRow
        self.startInclusive = startInclusive
        self.endRow = endRow
        self.endInclusive = endInclusive

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.SET:
                    self.auths = set()
                    (_etype221, _size218) = iprot.readSetBegin()
                    for _i222 in range(_size218):
                        _elem223 = iprot.readBinary()
                        self.auths.add(_elem223)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.startRow = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.startInclusive = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.endRow = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.endInclusive = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getMaxRow_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.auths is not None:
            oprot.writeFieldBegin('auths', TType.SET, 3)
            oprot.writeSetBegin(TType.STRING, len(self.auths))
            for iter224 in self.auths:
                oprot.writeBinary(iter224)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.startRow is not None:
            oprot.writeFieldBegin('startRow', TType.STRING, 4)
            oprot.writeBinary(self.startRow)
            oprot.writeFieldEnd()
        if self.startInclusive is not None:
            oprot.writeFieldBegin('startInclusive', TType.BOOL, 5)
            oprot.writeBool(self.startInclusive)
            oprot.writeFieldEnd()
        if self.endRow is not None:
            oprot.writeFieldBegin('endRow', TType.STRING, 6)
            oprot.writeBinary(self.endRow)
            oprot.writeFieldEnd()
        if self.endInclusive is not None:
            oprot.writeFieldBegin('endInclusive', TType.BOOL, 7)
            oprot.writeBool(self.endInclusive)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getMaxRow_args)
getMaxRow_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
    (3, TType.SET, 'auths', (TType.STRING, 'BINARY', False), None, ),  # 3
    (4, TType.STRING, 'startRow', 'BINARY', None, ),  # 4
    (5, TType.BOOL, 'startInclusive', None, None, ),  # 5
    (6, TType.STRING, 'endRow', 'BINARY', None, ),  # 6
    (7, TType.BOOL, 'endInclusive', None, None, ),  # 7
)


class getMaxRow_result(object):
    """
    Attributes:
     - success
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
        self.success = success
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = TableNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getMaxRow_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getMaxRow_result)
getMaxRow_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [TableNotFoundException, None], None, ),  # 3
)


class getTableProperties_args(object):
    """
    Attributes:
     - sharedSecret
     - tableName

    """


    def __init__(self, sharedSecret=None, tableName=None,):
        self.sharedSecret = sharedSecret
        self.tableName = tableName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getTableProperties_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getTableProperties_args)
getTableProperties_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
)


class getTableProperties_result(object):
    """
    Attributes:
     - success
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
        self.success = success
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype226, _vtype227, _size225) = iprot.readMapBegin()
                    for _i229 in range(_size225):
                        _key230 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val231 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key230] = _val231
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = TableNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getTableProperties_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter232, viter233 in self.success.items():
                oprot.writeString(kiter232.encode('utf-8') if sys.version_info[0] == 2 else kiter232)
                oprot.writeString(viter233.encode('utf-8') if sys.version_info[0] == 2 else viter233)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getTableProperties_result)
getTableProperties_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [TableNotFoundException, None], None, ),  # 3
)


class importDirectory_args(object):
    """
    Attributes:
     - sharedSecret
     - tableName
     - importDir
     - failureDir
     - setTime

    """


    def __init__(self, sharedSecret=None, tableName=None, importDir=None, failureDir=None, setTime=None,):
        self.sharedSecret = sharedSecret
        self.tableName = tableName
        self.importDir = importDir
        self.failureDir = failureDir
        self.setTime = setTime

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.importDir = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.failureDir = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.setTime = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('importDirectory_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.importDir is not None:
            oprot.writeFieldBegin('importDir', TType.STRING, 3)
            oprot.writeString(self.importDir.encode('utf-8') if sys.version_info[0] == 2 else self.importDir)
            oprot.writeFieldEnd()
        if self.failureDir is not None:
            oprot.writeFieldBegin('failureDir', TType.STRING, 4)
            oprot.writeString(self.failureDir.encode('utf-8') if sys.version_info[0] == 2 else self.failureDir)
            oprot.writeFieldEnd()
        if self.setTime is not None:
            oprot.writeFieldBegin('setTime', TType.BOOL, 5)
            oprot.writeBool(self.setTime)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(importDirectory_args)
importDirectory_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'importDir', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'failureDir', 'UTF8', None, ),  # 4
    (5, TType.BOOL, 'setTime', None, None, ),  # 5
)


class importDirectory_result(object):
    """
    Attributes:
     - ouch1
     - ouch3
     - ouch4

    """


    def __init__(self, ouch1=None, ouch3=None, ouch4=None,):
        self.ouch1 = ouch1
        self.ouch3 = ouch3
        self.ouch4 = ouch4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = TableNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch3 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch4 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('importDirectory_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 2)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch4 is not None:
            oprot.writeFieldBegin('ouch4', TType.STRUCT, 3)
            self.ouch4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(importDirectory_result)
importDirectory_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [TableNotFoundException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch3', [AccumuloException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch4', [AccumuloSecurityException, None], None, ),  # 3
)


class importTable_args(object):
    """
    Attributes:
     - sharedSecret
     - tableName
     - importDir

    """


    def __init__(self, sharedSecret=None, tableName=None, importDir=None,):
        self.sharedSecret = sharedSecret
        self.tableName = tableName
        self.importDir = importDir

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.importDir = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('importTable_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.importDir is not None:
            oprot.writeFieldBegin('importDir', TType.STRING, 3)
            oprot.writeString(self.importDir.encode('utf-8') if sys.version_info[0] == 2 else self.importDir)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(importTable_args)
importTable_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'importDir', 'UTF8', None, ),  # 3
)


class importTable_result(object):
    """
    Attributes:
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = TableExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('importTable_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(importTable_result)
importTable_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [TableExistsException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [AccumuloSecurityException, None], None, ),  # 3
)


class listSplits_args(object):
    """
    Attributes:
     - sharedSecret
     - tableName
     - maxSplits

    """


    def __init__(self, sharedSecret=None, tableName=None, maxSplits=None,):
        self.sharedSecret = sharedSecret
        self.tableName = tableName
        self.maxSplits = maxSplits

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.maxSplits = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('listSplits_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.maxSplits is not None:
            oprot.writeFieldBegin('maxSplits', TType.I32, 3)
            oprot.writeI32(self.maxSplits)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(listSplits_args)
listSplits_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
    (3, TType.I32, 'maxSplits', None, None, ),  # 3
)


class listSplits_result(object):
    """
    Attributes:
     - success
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
        self.success = success
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype237, _size234) = iprot.readListBegin()
                    for _i238 in range(_size234):
                        _elem239 = iprot.readBinary()
                        self.success.append(_elem239)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = TableNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('listSplits_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter240 in self.success:
                oprot.writeBinary(iter240)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(listSplits_result)
listSplits_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'BINARY', False), None, ),  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [TableNotFoundException, None], None, ),  # 3
)


class listTables_args(object):
    """
    Attributes:
     - sharedSecret

    """


    def __init__(self, sharedSecret=None,):
        self.sharedSecret = sharedSecret

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('listTables_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(listTables_args)
listTables_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
)


class listTables_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.SET:
                    self.success = set()
                    (_etype244, _size241) = iprot.readSetBegin()
                    for _i245 in range(_size241):
                        _elem246 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.add(_elem246)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('listTables_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.SET, 0)
            oprot.writeSetBegin(TType.STRING, len(self.success))
            for iter247 in self.success:
                oprot.writeString(iter247.encode('utf-8') if sys.version_info[0] == 2 else iter247)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(listTables_result)
listTables_result.thrift_spec = (
    (0, TType.SET, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
)


class listIterators_args(object):
    """
    Attributes:
     - sharedSecret
     - tableName

    """


    def __init__(self, sharedSecret=None, tableName=None,):
        self.sharedSecret = sharedSecret
        self.tableName = tableName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('listIterators_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(listIterators_args)
listIterators_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
)


class listIterators_result(object):
    """
    Attributes:
     - success
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
        self.success = success
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype249, _vtype250, _size248) = iprot.readMapBegin()
                    for _i252 in range(_size248):
                        _key253 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val254 = set()
                        (_etype258, _size255) = iprot.readSetBegin()
                        for _i259 in range(_size255):
                            _elem260 = iprot.readI32()
                            _val254.add(_elem260)
                        iprot.readSetEnd()
                        self.success[_key253] = _val254
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = TableNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('listIterators_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.SET, len(self.success))
            for kiter261, viter262 in self.success.items():
                oprot.writeString(kiter261.encode('utf-8') if sys.version_info[0] == 2 else kiter261)
                oprot.writeSetBegin(TType.I32, len(viter262))
                for iter263 in viter262:
                    oprot.writeI32(iter263)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(listIterators_result)
listIterators_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.SET, (TType.I32, None, False), False), None, ),  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [TableNotFoundException, None], None, ),  # 3
)


class listConstraints_args(object):
    """
    Attributes:
     - sharedSecret
     - tableName

    """


    def __init__(self, sharedSecret=None, tableName=None,):
        self.sharedSecret = sharedSecret
        self.tableName = tableName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('listConstraints_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(listConstraints_args)
listConstraints_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
)


class listConstraints_result(object):
    """
    Attributes:
     - success
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
        self.success = success
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype265, _vtype266, _size264) = iprot.readMapBegin()
                    for _i268 in range(_size264):
                        _key269 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val270 = iprot.readI32()
                        self.success[_key269] = _val270
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = TableNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('listConstraints_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.I32, len(self.success))
            for kiter271, viter272 in self.success.items():
                oprot.writeString(kiter271.encode('utf-8') if sys.version_info[0] == 2 else kiter271)
                oprot.writeI32(viter272)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(listConstraints_result)
listConstraints_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.I32, None, False), None, ),  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [TableNotFoundException, None], None, ),  # 3
)


class mergeTablets_args(object):
    """
    Attributes:
     - sharedSecret
     - tableName
     - startRow
     - endRow

    """


    def __init__(self, sharedSecret=None, tableName=None, startRow=None, endRow=None,):
        self.sharedSecret = sharedSecret
        self.tableName = tableName
        self.startRow = startRow
        self.endRow = endRow

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.startRow = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.endRow = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mergeTablets_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.startRow is not None:
            oprot.writeFieldBegin('startRow', TType.STRING, 3)
            oprot.writeBinary(self.startRow)
            oprot.writeFieldEnd()
        if self.endRow is not None:
            oprot.writeFieldBegin('endRow', TType.STRING, 4)
            oprot.writeBinary(self.endRow)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mergeTablets_args)
mergeTablets_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'startRow', 'BINARY', None, ),  # 3
    (4, TType.STRING, 'endRow', 'BINARY', None, ),  # 4
)


class mergeTablets_result(object):
    """
    Attributes:
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = TableNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mergeTablets_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mergeTablets_result)
mergeTablets_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [TableNotFoundException, None], None, ),  # 3
)


class offlineTable_args(object):
    """
    Attributes:
     - sharedSecret
     - tableName
     - wait

    """


    def __init__(self, sharedSecret=None, tableName=None, wait=False,):
        self.sharedSecret = sharedSecret
        self.tableName = tableName
        self.wait = wait

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.wait = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('offlineTable_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.wait is not None:
            oprot.writeFieldBegin('wait', TType.BOOL, 3)
            oprot.writeBool(self.wait)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(offlineTable_args)
offlineTable_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'wait', None, False, ),  # 3
)


class offlineTable_result(object):
    """
    Attributes:
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = TableNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('offlineTable_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(offlineTable_result)
offlineTable_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [TableNotFoundException, None], None, ),  # 3
)


class onlineTable_args(object):
    """
    Attributes:
     - sharedSecret
     - tableName
     - wait

    """


    def __init__(self, sharedSecret=None, tableName=None, wait=False,):
        self.sharedSecret = sharedSecret
        self.tableName = tableName
        self.wait = wait

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.wait = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('onlineTable_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.wait is not None:
            oprot.writeFieldBegin('wait', TType.BOOL, 3)
            oprot.writeBool(self.wait)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(onlineTable_args)
onlineTable_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'wait', None, False, ),  # 3
)


class onlineTable_result(object):
    """
    Attributes:
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = TableNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('onlineTable_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(onlineTable_result)
onlineTable_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [TableNotFoundException, None], None, ),  # 3
)


class removeConstraint_args(object):
    """
    Attributes:
     - sharedSecret
     - tableName
     - constraint

    """


    def __init__(self, sharedSecret=None, tableName=None, constraint=None,):
        self.sharedSecret = sharedSecret
        self.tableName = tableName
        self.constraint = constraint

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.constraint = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeConstraint_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.constraint is not None:
            oprot.writeFieldBegin('constraint', TType.I32, 3)
            oprot.writeI32(self.constraint)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeConstraint_args)
removeConstraint_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
    (3, TType.I32, 'constraint', None, None, ),  # 3
)


class removeConstraint_result(object):
    """
    Attributes:
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = TableNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeConstraint_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeConstraint_result)
removeConstraint_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [TableNotFoundException, None], None, ),  # 3
)


class removeIterator_args(object):
    """
    Attributes:
     - sharedSecret
     - tableName
     - iterName
     - scopes

    """


    def __init__(self, sharedSecret=None, tableName=None, iterName=None, scopes=None,):
        self.sharedSecret = sharedSecret
        self.tableName = tableName
        self.iterName = iterName
        self.scopes = scopes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.iterName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.SET:
                    self.scopes = set()
                    (_etype276, _size273) = iprot.readSetBegin()
                    for _i277 in range(_size273):
                        _elem278 = iprot.readI32()
                        self.scopes.add(_elem278)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeIterator_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.iterName is not None:
            oprot.writeFieldBegin('iterName', TType.STRING, 3)
            oprot.writeString(self.iterName.encode('utf-8') if sys.version_info[0] == 2 else self.iterName)
            oprot.writeFieldEnd()
        if self.scopes is not None:
            oprot.writeFieldBegin('scopes', TType.SET, 4)
            oprot.writeSetBegin(TType.I32, len(self.scopes))
            for iter279 in self.scopes:
                oprot.writeI32(iter279)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeIterator_args)
removeIterator_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'iterName', 'UTF8', None, ),  # 3
    (4, TType.SET, 'scopes', (TType.I32, None, False), None, ),  # 4
)


class removeIterator_result(object):
    """
    Attributes:
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = TableNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeIterator_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeIterator_result)
removeIterator_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [TableNotFoundException, None], None, ),  # 3
)


class removeTableProperty_args(object):
    """
    Attributes:
     - sharedSecret
     - tableName
     - property

    """


    def __init__(self, sharedSecret=None, tableName=None, property=None,):
        self.sharedSecret = sharedSecret
        self.tableName = tableName
        self.property = property

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.property = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeTableProperty_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.property is not None:
            oprot.writeFieldBegin('property', TType.STRING, 3)
            oprot.writeString(self.property.encode('utf-8') if sys.version_info[0] == 2 else self.property)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeTableProperty_args)
removeTableProperty_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'property', 'UTF8', None, ),  # 3
)


class removeTableProperty_result(object):
    """
    Attributes:
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = TableNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeTableProperty_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeTableProperty_result)
removeTableProperty_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [TableNotFoundException, None], None, ),  # 3
)


class renameTable_args(object):
    """
    Attributes:
     - sharedSecret
     - oldTableName
     - newTableName

    """


    def __init__(self, sharedSecret=None, oldTableName=None, newTableName=None,):
        self.sharedSecret = sharedSecret
        self.oldTableName = oldTableName
        self.newTableName = newTableName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.oldTableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.newTableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('renameTable_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.oldTableName is not None:
            oprot.writeFieldBegin('oldTableName', TType.STRING, 2)
            oprot.writeString(self.oldTableName.encode('utf-8') if sys.version_info[0] == 2 else self.oldTableName)
            oprot.writeFieldEnd()
        if self.newTableName is not None:
            oprot.writeFieldBegin('newTableName', TType.STRING, 3)
            oprot.writeString(self.newTableName.encode('utf-8') if sys.version_info[0] == 2 else self.newTableName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(renameTable_args)
renameTable_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'oldTableName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'newTableName', 'UTF8', None, ),  # 3
)


class renameTable_result(object):
    """
    Attributes:
     - ouch1
     - ouch2
     - ouch3
     - ouch4

    """


    def __init__(self, ouch1=None, ouch2=None, ouch3=None, ouch4=None,):
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3
        self.ouch4 = ouch4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = TableNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ouch4 = TableExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('renameTable_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch4 is not None:
            oprot.writeFieldBegin('ouch4', TType.STRUCT, 4)
            self.ouch4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(renameTable_result)
renameTable_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [TableNotFoundException, None], None, ),  # 3
    (4, TType.STRUCT, 'ouch4', [TableExistsException, None], None, ),  # 4
)


class setLocalityGroups_args(object):
    """
    Attributes:
     - sharedSecret
     - tableName
     - groups

    """


    def __init__(self, sharedSecret=None, tableName=None, groups=None,):
        self.sharedSecret = sharedSecret
        self.tableName = tableName
        self.groups = groups

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.groups = {}
                    (_ktype281, _vtype282, _size280) = iprot.readMapBegin()
                    for _i284 in range(_size280):
                        _key285 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val286 = set()
                        (_etype290, _size287) = iprot.readSetBegin()
                        for _i291 in range(_size287):
                            _elem292 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val286.add(_elem292)
                        iprot.readSetEnd()
                        self.groups[_key285] = _val286
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setLocalityGroups_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.groups is not None:
            oprot.writeFieldBegin('groups', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.SET, len(self.groups))
            for kiter293, viter294 in self.groups.items():
                oprot.writeString(kiter293.encode('utf-8') if sys.version_info[0] == 2 else kiter293)
                oprot.writeSetBegin(TType.STRING, len(viter294))
                for iter295 in viter294:
                    oprot.writeString(iter295.encode('utf-8') if sys.version_info[0] == 2 else iter295)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setLocalityGroups_args)
setLocalityGroups_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
    (3, TType.MAP, 'groups', (TType.STRING, 'UTF8', TType.SET, (TType.STRING, 'UTF8', False), False), None, ),  # 3
)


class setLocalityGroups_result(object):
    """
    Attributes:
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = TableNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setLocalityGroups_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setLocalityGroups_result)
setLocalityGroups_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [TableNotFoundException, None], None, ),  # 3
)


class setTableProperty_args(object):
    """
    Attributes:
     - sharedSecret
     - tableName
     - property
     - value

    """


    def __init__(self, sharedSecret=None, tableName=None, property=None, value=None,):
        self.sharedSecret = sharedSecret
        self.tableName = tableName
        self.property = property
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.property = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setTableProperty_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.property is not None:
            oprot.writeFieldBegin('property', TType.STRING, 3)
            oprot.writeString(self.property.encode('utf-8') if sys.version_info[0] == 2 else self.property)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 4)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setTableProperty_args)
setTableProperty_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'property', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'value', 'UTF8', None, ),  # 4
)


class setTableProperty_result(object):
    """
    Attributes:
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = TableNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setTableProperty_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setTableProperty_result)
setTableProperty_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [TableNotFoundException, None], None, ),  # 3
)


class splitRangeByTablets_args(object):
    """
    Attributes:
     - sharedSecret
     - tableName
     - range
     - maxSplits

    """


    def __init__(self, sharedSecret=None, tableName=None, range=None, maxSplits=None,):
        self.sharedSecret = sharedSecret
        self.tableName = tableName
        self.range = range
        self.maxSplits = maxSplits

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.range = Range()
                    self.range.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.maxSplits = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('splitRangeByTablets_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.range is not None:
            oprot.writeFieldBegin('range', TType.STRUCT, 3)
            self.range.write(oprot)
            oprot.writeFieldEnd()
        if self.maxSplits is not None:
            oprot.writeFieldBegin('maxSplits', TType.I32, 4)
            oprot.writeI32(self.maxSplits)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(splitRangeByTablets_args)
splitRangeByTablets_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'range', [Range, None], None, ),  # 3
    (4, TType.I32, 'maxSplits', None, None, ),  # 4
)


class splitRangeByTablets_result(object):
    """
    Attributes:
     - success
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
        self.success = success
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.SET:
                    self.success = set()
                    (_etype299, _size296) = iprot.readSetBegin()
                    for _i300 in range(_size296):
                        _elem301 = Range()
                        _elem301.read(iprot)
                        self.success.add(_elem301)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = TableNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('splitRangeByTablets_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.SET, 0)
            oprot.writeSetBegin(TType.STRUCT, len(self.success))
            for iter302 in self.success:
                iter302.write(oprot)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(splitRangeByTablets_result)
splitRangeByTablets_result.thrift_spec = (
    (0, TType.SET, 'success', (TType.STRUCT, [Range, None], False), None, ),  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [TableNotFoundException, None], None, ),  # 3
)


class tableExists_args(object):
    """
    Attributes:
     - sharedSecret
     - tableName

    """


    def __init__(self, sharedSecret=None, tableName=None,):
        self.sharedSecret = sharedSecret
        self.tableName = tableName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tableExists_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tableExists_args)
tableExists_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
)


class tableExists_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tableExists_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tableExists_result)
tableExists_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class tableIdMap_args(object):
    """
    Attributes:
     - sharedSecret

    """


    def __init__(self, sharedSecret=None,):
        self.sharedSecret = sharedSecret

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tableIdMap_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tableIdMap_args)
tableIdMap_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
)


class tableIdMap_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype304, _vtype305, _size303) = iprot.readMapBegin()
                    for _i307 in range(_size303):
                        _key308 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val309 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key308] = _val309
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tableIdMap_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter310, viter311 in self.success.items():
                oprot.writeString(kiter310.encode('utf-8') if sys.version_info[0] == 2 else kiter310)
                oprot.writeString(viter311.encode('utf-8') if sys.version_info[0] == 2 else viter311)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tableIdMap_result)
tableIdMap_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
)


class testTableClassLoad_args(object):
    """
    Attributes:
     - sharedSecret
     - tableName
     - className
     - asTypeName

    """


    def __init__(self, sharedSecret=None, tableName=None, className=None, asTypeName=None,):
        self.sharedSecret = sharedSecret
        self.tableName = tableName
        self.className = className
        self.asTypeName = asTypeName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.className = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.asTypeName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testTableClassLoad_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.className is not None:
            oprot.writeFieldBegin('className', TType.STRING, 3)
            oprot.writeString(self.className.encode('utf-8') if sys.version_info[0] == 2 else self.className)
            oprot.writeFieldEnd()
        if self.asTypeName is not None:
            oprot.writeFieldBegin('asTypeName', TType.STRING, 4)
            oprot.writeString(self.asTypeName.encode('utf-8') if sys.version_info[0] == 2 else self.asTypeName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testTableClassLoad_args)
testTableClassLoad_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'className', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'asTypeName', 'UTF8', None, ),  # 4
)


class testTableClassLoad_result(object):
    """
    Attributes:
     - success
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
        self.success = success
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = TableNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testTableClassLoad_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testTableClassLoad_result)
testTableClassLoad_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [TableNotFoundException, None], None, ),  # 3
)


class pingTabletServer_args(object):
    """
    Attributes:
     - sharedSecret
     - tserver

    """


    def __init__(self, sharedSecret=None, tserver=None,):
        self.sharedSecret = sharedSecret
        self.tserver = tserver

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tserver = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pingTabletServer_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.tserver is not None:
            oprot.writeFieldBegin('tserver', TType.STRING, 2)
            oprot.writeString(self.tserver.encode('utf-8') if sys.version_info[0] == 2 else self.tserver)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pingTabletServer_args)
pingTabletServer_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tserver', 'UTF8', None, ),  # 2
)


class pingTabletServer_result(object):
    """
    Attributes:
     - ouch1
     - ouch2

    """


    def __init__(self, ouch1=None, ouch2=None,):
        self.ouch1 = ouch1
        self.ouch2 = ouch2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pingTabletServer_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pingTabletServer_result)
pingTabletServer_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
)


class getActiveScans_args(object):
    """
    Attributes:
     - sharedSecret
     - tserver

    """


    def __init__(self, sharedSecret=None, tserver=None,):
        self.sharedSecret = sharedSecret
        self.tserver = tserver

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tserver = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getActiveScans_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.tserver is not None:
            oprot.writeFieldBegin('tserver', TType.STRING, 2)
            oprot.writeString(self.tserver.encode('utf-8') if sys.version_info[0] == 2 else self.tserver)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getActiveScans_args)
getActiveScans_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tserver', 'UTF8', None, ),  # 2
)


class getActiveScans_result(object):
    """
    Attributes:
     - success
     - ouch1
     - ouch2

    """


    def __init__(self, success=None, ouch1=None, ouch2=None,):
        self.success = success
        self.ouch1 = ouch1
        self.ouch2 = ouch2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype315, _size312) = iprot.readListBegin()
                    for _i316 in range(_size312):
                        _elem317 = ActiveScan()
                        _elem317.read(iprot)
                        self.success.append(_elem317)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getActiveScans_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter318 in self.success:
                iter318.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getActiveScans_result)
getActiveScans_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ActiveScan, None], False), None, ),  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
)


class getActiveCompactions_args(object):
    """
    Attributes:
     - sharedSecret
     - tserver

    """


    def __init__(self, sharedSecret=None, tserver=None,):
        self.sharedSecret = sharedSecret
        self.tserver = tserver

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tserver = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getActiveCompactions_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.tserver is not None:
            oprot.writeFieldBegin('tserver', TType.STRING, 2)
            oprot.writeString(self.tserver.encode('utf-8') if sys.version_info[0] == 2 else self.tserver)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getActiveCompactions_args)
getActiveCompactions_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tserver', 'UTF8', None, ),  # 2
)


class getActiveCompactions_result(object):
    """
    Attributes:
     - success
     - ouch1
     - ouch2

    """


    def __init__(self, success=None, ouch1=None, ouch2=None,):
        self.success = success
        self.ouch1 = ouch1
        self.ouch2 = ouch2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype322, _size319) = iprot.readListBegin()
                    for _i323 in range(_size319):
                        _elem324 = ActiveCompaction()
                        _elem324.read(iprot)
                        self.success.append(_elem324)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getActiveCompactions_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter325 in self.success:
                iter325.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getActiveCompactions_result)
getActiveCompactions_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ActiveCompaction, None], False), None, ),  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
)


class getSiteConfiguration_args(object):
    """
    Attributes:
     - sharedSecret

    """


    def __init__(self, sharedSecret=None,):
        self.sharedSecret = sharedSecret

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getSiteConfiguration_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getSiteConfiguration_args)
getSiteConfiguration_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
)


class getSiteConfiguration_result(object):
    """
    Attributes:
     - success
     - ouch1
     - ouch2

    """


    def __init__(self, success=None, ouch1=None, ouch2=None,):
        self.success = success
        self.ouch1 = ouch1
        self.ouch2 = ouch2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype327, _vtype328, _size326) = iprot.readMapBegin()
                    for _i330 in range(_size326):
                        _key331 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val332 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key331] = _val332
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getSiteConfiguration_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter333, viter334 in self.success.items():
                oprot.writeString(kiter333.encode('utf-8') if sys.version_info[0] == 2 else kiter333)
                oprot.writeString(viter334.encode('utf-8') if sys.version_info[0] == 2 else viter334)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getSiteConfiguration_result)
getSiteConfiguration_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
)


class getSystemConfiguration_args(object):
    """
    Attributes:
     - sharedSecret

    """


    def __init__(self, sharedSecret=None,):
        self.sharedSecret = sharedSecret

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getSystemConfiguration_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getSystemConfiguration_args)
getSystemConfiguration_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
)


class getSystemConfiguration_result(object):
    """
    Attributes:
     - success
     - ouch1
     - ouch2

    """


    def __init__(self, success=None, ouch1=None, ouch2=None,):
        self.success = success
        self.ouch1 = ouch1
        self.ouch2 = ouch2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype336, _vtype337, _size335) = iprot.readMapBegin()
                    for _i339 in range(_size335):
                        _key340 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val341 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key340] = _val341
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getSystemConfiguration_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter342, viter343 in self.success.items():
                oprot.writeString(kiter342.encode('utf-8') if sys.version_info[0] == 2 else kiter342)
                oprot.writeString(viter343.encode('utf-8') if sys.version_info[0] == 2 else viter343)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getSystemConfiguration_result)
getSystemConfiguration_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
)


class getTabletServers_args(object):
    """
    Attributes:
     - sharedSecret

    """


    def __init__(self, sharedSecret=None,):
        self.sharedSecret = sharedSecret

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getTabletServers_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getTabletServers_args)
getTabletServers_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
)


class getTabletServers_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype347, _size344) = iprot.readListBegin()
                    for _i348 in range(_size344):
                        _elem349 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem349)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getTabletServers_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter350 in self.success:
                oprot.writeString(iter350.encode('utf-8') if sys.version_info[0] == 2 else iter350)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getTabletServers_result)
getTabletServers_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
)


class removeProperty_args(object):
    """
    Attributes:
     - sharedSecret
     - property

    """


    def __init__(self, sharedSecret=None, property=None,):
        self.sharedSecret = sharedSecret
        self.property = property

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.property = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeProperty_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.property is not None:
            oprot.writeFieldBegin('property', TType.STRING, 2)
            oprot.writeString(self.property.encode('utf-8') if sys.version_info[0] == 2 else self.property)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeProperty_args)
removeProperty_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'property', 'UTF8', None, ),  # 2
)


class removeProperty_result(object):
    """
    Attributes:
     - ouch1
     - ouch2

    """


    def __init__(self, ouch1=None, ouch2=None,):
        self.ouch1 = ouch1
        self.ouch2 = ouch2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeProperty_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeProperty_result)
removeProperty_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
)


class setProperty_args(object):
    """
    Attributes:
     - sharedSecret
     - property
     - value

    """


    def __init__(self, sharedSecret=None, property=None, value=None,):
        self.sharedSecret = sharedSecret
        self.property = property
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.property = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setProperty_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.property is not None:
            oprot.writeFieldBegin('property', TType.STRING, 2)
            oprot.writeString(self.property.encode('utf-8') if sys.version_info[0] == 2 else self.property)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 3)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setProperty_args)
setProperty_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'property', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'value', 'UTF8', None, ),  # 3
)


class setProperty_result(object):
    """
    Attributes:
     - ouch1
     - ouch2

    """


    def __init__(self, ouch1=None, ouch2=None,):
        self.ouch1 = ouch1
        self.ouch2 = ouch2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setProperty_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setProperty_result)
setProperty_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
)


class testClassLoad_args(object):
    """
    Attributes:
     - sharedSecret
     - className
     - asTypeName

    """


    def __init__(self, sharedSecret=None, className=None, asTypeName=None,):
        self.sharedSecret = sharedSecret
        self.className = className
        self.asTypeName = asTypeName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.className = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.asTypeName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testClassLoad_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.className is not None:
            oprot.writeFieldBegin('className', TType.STRING, 2)
            oprot.writeString(self.className.encode('utf-8') if sys.version_info[0] == 2 else self.className)
            oprot.writeFieldEnd()
        if self.asTypeName is not None:
            oprot.writeFieldBegin('asTypeName', TType.STRING, 3)
            oprot.writeString(self.asTypeName.encode('utf-8') if sys.version_info[0] == 2 else self.asTypeName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testClassLoad_args)
testClassLoad_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'className', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'asTypeName', 'UTF8', None, ),  # 3
)


class testClassLoad_result(object):
    """
    Attributes:
     - success
     - ouch1
     - ouch2

    """


    def __init__(self, success=None, ouch1=None, ouch2=None,):
        self.success = success
        self.ouch1 = ouch1
        self.ouch2 = ouch2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testClassLoad_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testClassLoad_result)
testClassLoad_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
)


class authenticateUser_args(object):
    """
    Attributes:
     - sharedSecret
     - user
     - properties

    """


    def __init__(self, sharedSecret=None, user=None, properties=None,):
        self.sharedSecret = sharedSecret
        self.user = user
        self.properties = properties

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.user = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.properties = {}
                    (_ktype352, _vtype353, _size351) = iprot.readMapBegin()
                    for _i355 in range(_size351):
                        _key356 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val357 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.properties[_key356] = _val357
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('authenticateUser_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.user is not None:
            oprot.writeFieldBegin('user', TType.STRING, 2)
            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
            oprot.writeFieldEnd()
        if self.properties is not None:
            oprot.writeFieldBegin('properties', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.properties))
            for kiter358, viter359 in self.properties.items():
                oprot.writeString(kiter358.encode('utf-8') if sys.version_info[0] == 2 else kiter358)
                oprot.writeString(viter359.encode('utf-8') if sys.version_info[0] == 2 else viter359)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(authenticateUser_args)
authenticateUser_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
    (3, TType.MAP, 'properties', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 3
)


class authenticateUser_result(object):
    """
    Attributes:
     - success
     - ouch1
     - ouch2

    """


    def __init__(self, success=None, ouch1=None, ouch2=None,):
        self.success = success
        self.ouch1 = ouch1
        self.ouch2 = ouch2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('authenticateUser_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(authenticateUser_result)
authenticateUser_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
)


class changeUserAuthorizations_args(object):
    """
    Attributes:
     - sharedSecret
     - user
     - authorizations

    """


    def __init__(self, sharedSecret=None, user=None, authorizations=None,):
        self.sharedSecret = sharedSecret
        self.user = user
        self.authorizations = authorizations

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.user = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.SET:
                    self.authorizations = set()
                    (_etype363, _size360) = iprot.readSetBegin()
                    for _i364 in range(_size360):
                        _elem365 = iprot.readBinary()
                        self.authorizations.add(_elem365)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('changeUserAuthorizations_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.user is not None:
            oprot.writeFieldBegin('user', TType.STRING, 2)
            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
            oprot.writeFieldEnd()
        if self.authorizations is not None:
            oprot.writeFieldBegin('authorizations', TType.SET, 3)
            oprot.writeSetBegin(TType.STRING, len(self.authorizations))
            for iter366 in self.authorizations:
                oprot.writeBinary(iter366)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(changeUserAuthorizations_args)
changeUserAuthorizations_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
    (3, TType.SET, 'authorizations', (TType.STRING, 'BINARY', False), None, ),  # 3
)


class changeUserAuthorizations_result(object):
    """
    Attributes:
     - ouch1
     - ouch2

    """


    def __init__(self, ouch1=None, ouch2=None,):
        self.ouch1 = ouch1
        self.ouch2 = ouch2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('changeUserAuthorizations_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(changeUserAuthorizations_result)
changeUserAuthorizations_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
)


class changeLocalUserPassword_args(object):
    """
    Attributes:
     - sharedSecret
     - user
     - password

    """


    def __init__(self, sharedSecret=None, user=None, password=None,):
        self.sharedSecret = sharedSecret
        self.user = user
        self.password = password

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.user = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.password = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('changeLocalUserPassword_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.user is not None:
            oprot.writeFieldBegin('user', TType.STRING, 2)
            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
            oprot.writeFieldEnd()
        if self.password is not None:
            oprot.writeFieldBegin('password', TType.STRING, 3)
            oprot.writeBinary(self.password)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(changeLocalUserPassword_args)
changeLocalUserPassword_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'password', 'BINARY', None, ),  # 3
)


class changeLocalUserPassword_result(object):
    """
    Attributes:
     - ouch1
     - ouch2

    """


    def __init__(self, ouch1=None, ouch2=None,):
        self.ouch1 = ouch1
        self.ouch2 = ouch2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('changeLocalUserPassword_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(changeLocalUserPassword_result)
changeLocalUserPassword_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
)


class createLocalUser_args(object):
    """
    Attributes:
     - sharedSecret
     - user
     - password

    """


    def __init__(self, sharedSecret=None, user=None, password=None,):
        self.sharedSecret = sharedSecret
        self.user = user
        self.password = password

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.user = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.password = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createLocalUser_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.user is not None:
            oprot.writeFieldBegin('user', TType.STRING, 2)
            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
            oprot.writeFieldEnd()
        if self.password is not None:
            oprot.writeFieldBegin('password', TType.STRING, 3)
            oprot.writeBinary(self.password)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createLocalUser_args)
createLocalUser_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'password', 'BINARY', None, ),  # 3
)


class createLocalUser_result(object):
    """
    Attributes:
     - ouch1
     - ouch2

    """


    def __init__(self, ouch1=None, ouch2=None,):
        self.ouch1 = ouch1
        self.ouch2 = ouch2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createLocalUser_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createLocalUser_result)
createLocalUser_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
)


class dropLocalUser_args(object):
    """
    Attributes:
     - sharedSecret
     - user

    """


    def __init__(self, sharedSecret=None, user=None,):
        self.sharedSecret = sharedSecret
        self.user = user

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.user = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dropLocalUser_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.user is not None:
            oprot.writeFieldBegin('user', TType.STRING, 2)
            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dropLocalUser_args)
dropLocalUser_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
)


class dropLocalUser_result(object):
    """
    Attributes:
     - ouch1
     - ouch2

    """


    def __init__(self, ouch1=None, ouch2=None,):
        self.ouch1 = ouch1
        self.ouch2 = ouch2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('dropLocalUser_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(dropLocalUser_result)
dropLocalUser_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
)


class getUserAuthorizations_args(object):
    """
    Attributes:
     - sharedSecret
     - user

    """


    def __init__(self, sharedSecret=None, user=None,):
        self.sharedSecret = sharedSecret
        self.user = user

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.user = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getUserAuthorizations_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.user is not None:
            oprot.writeFieldBegin('user', TType.STRING, 2)
            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getUserAuthorizations_args)
getUserAuthorizations_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
)


class getUserAuthorizations_result(object):
    """
    Attributes:
     - success
     - ouch1
     - ouch2

    """


    def __init__(self, success=None, ouch1=None, ouch2=None,):
        self.success = success
        self.ouch1 = ouch1
        self.ouch2 = ouch2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype370, _size367) = iprot.readListBegin()
                    for _i371 in range(_size367):
                        _elem372 = iprot.readBinary()
                        self.success.append(_elem372)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getUserAuthorizations_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter373 in self.success:
                oprot.writeBinary(iter373)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getUserAuthorizations_result)
getUserAuthorizations_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'BINARY', False), None, ),  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
)


class grantSystemPermission_args(object):
    """
    Attributes:
     - sharedSecret
     - user
     - perm

    """


    def __init__(self, sharedSecret=None, user=None, perm=None,):
        self.sharedSecret = sharedSecret
        self.user = user
        self.perm = perm

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.user = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.perm = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('grantSystemPermission_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.user is not None:
            oprot.writeFieldBegin('user', TType.STRING, 2)
            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
            oprot.writeFieldEnd()
        if self.perm is not None:
            oprot.writeFieldBegin('perm', TType.I32, 3)
            oprot.writeI32(self.perm)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(grantSystemPermission_args)
grantSystemPermission_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
    (3, TType.I32, 'perm', None, None, ),  # 3
)


class grantSystemPermission_result(object):
    """
    Attributes:
     - ouch1
     - ouch2

    """


    def __init__(self, ouch1=None, ouch2=None,):
        self.ouch1 = ouch1
        self.ouch2 = ouch2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('grantSystemPermission_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(grantSystemPermission_result)
grantSystemPermission_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
)


class grantTablePermission_args(object):
    """
    Attributes:
     - sharedSecret
     - user
     - table
     - perm

    """


    def __init__(self, sharedSecret=None, user=None, table=None, perm=None,):
        self.sharedSecret = sharedSecret
        self.user = user
        self.table = table
        self.perm = perm

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.user = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.table = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.perm = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('grantTablePermission_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.user is not None:
            oprot.writeFieldBegin('user', TType.STRING, 2)
            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRING, 3)
            oprot.writeString(self.table.encode('utf-8') if sys.version_info[0] == 2 else self.table)
            oprot.writeFieldEnd()
        if self.perm is not None:
            oprot.writeFieldBegin('perm', TType.I32, 4)
            oprot.writeI32(self.perm)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(grantTablePermission_args)
grantTablePermission_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'table', 'UTF8', None, ),  # 3
    (4, TType.I32, 'perm', None, None, ),  # 4
)


class grantTablePermission_result(object):
    """
    Attributes:
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = TableNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('grantTablePermission_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(grantTablePermission_result)
grantTablePermission_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [TableNotFoundException, None], None, ),  # 3
)


class hasSystemPermission_args(object):
    """
    Attributes:
     - sharedSecret
     - user
     - perm

    """


    def __init__(self, sharedSecret=None, user=None, perm=None,):
        self.sharedSecret = sharedSecret
        self.user = user
        self.perm = perm

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.user = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.perm = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('hasSystemPermission_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.user is not None:
            oprot.writeFieldBegin('user', TType.STRING, 2)
            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
            oprot.writeFieldEnd()
        if self.perm is not None:
            oprot.writeFieldBegin('perm', TType.I32, 3)
            oprot.writeI32(self.perm)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(hasSystemPermission_args)
hasSystemPermission_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
    (3, TType.I32, 'perm', None, None, ),  # 3
)


class hasSystemPermission_result(object):
    """
    Attributes:
     - success
     - ouch1
     - ouch2

    """


    def __init__(self, success=None, ouch1=None, ouch2=None,):
        self.success = success
        self.ouch1 = ouch1
        self.ouch2 = ouch2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('hasSystemPermission_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(hasSystemPermission_result)
hasSystemPermission_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
)


class hasTablePermission_args(object):
    """
    Attributes:
     - sharedSecret
     - user
     - table
     - perm

    """


    def __init__(self, sharedSecret=None, user=None, table=None, perm=None,):
        self.sharedSecret = sharedSecret
        self.user = user
        self.table = table
        self.perm = perm

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.user = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.table = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.perm = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('hasTablePermission_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.user is not None:
            oprot.writeFieldBegin('user', TType.STRING, 2)
            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRING, 3)
            oprot.writeString(self.table.encode('utf-8') if sys.version_info[0] == 2 else self.table)
            oprot.writeFieldEnd()
        if self.perm is not None:
            oprot.writeFieldBegin('perm', TType.I32, 4)
            oprot.writeI32(self.perm)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(hasTablePermission_args)
hasTablePermission_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'table', 'UTF8', None, ),  # 3
    (4, TType.I32, 'perm', None, None, ),  # 4
)


class hasTablePermission_result(object):
    """
    Attributes:
     - success
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
        self.success = success
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = TableNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('hasTablePermission_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(hasTablePermission_result)
hasTablePermission_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [TableNotFoundException, None], None, ),  # 3
)


class listLocalUsers_args(object):
    """
    Attributes:
     - sharedSecret

    """


    def __init__(self, sharedSecret=None,):
        self.sharedSecret = sharedSecret

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('listLocalUsers_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(listLocalUsers_args)
listLocalUsers_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
)


class listLocalUsers_result(object):
    """
    Attributes:
     - success
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
        self.success = success
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.SET:
                    self.success = set()
                    (_etype377, _size374) = iprot.readSetBegin()
                    for _i378 in range(_size374):
                        _elem379 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.add(_elem379)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = TableNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('listLocalUsers_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.SET, 0)
            oprot.writeSetBegin(TType.STRING, len(self.success))
            for iter380 in self.success:
                oprot.writeString(iter380.encode('utf-8') if sys.version_info[0] == 2 else iter380)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(listLocalUsers_result)
listLocalUsers_result.thrift_spec = (
    (0, TType.SET, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [TableNotFoundException, None], None, ),  # 3
)


class revokeSystemPermission_args(object):
    """
    Attributes:
     - sharedSecret
     - user
     - perm

    """


    def __init__(self, sharedSecret=None, user=None, perm=None,):
        self.sharedSecret = sharedSecret
        self.user = user
        self.perm = perm

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.user = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.perm = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('revokeSystemPermission_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.user is not None:
            oprot.writeFieldBegin('user', TType.STRING, 2)
            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
            oprot.writeFieldEnd()
        if self.perm is not None:
            oprot.writeFieldBegin('perm', TType.I32, 3)
            oprot.writeI32(self.perm)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(revokeSystemPermission_args)
revokeSystemPermission_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
    (3, TType.I32, 'perm', None, None, ),  # 3
)


class revokeSystemPermission_result(object):
    """
    Attributes:
     - ouch1
     - ouch2

    """


    def __init__(self, ouch1=None, ouch2=None,):
        self.ouch1 = ouch1
        self.ouch2 = ouch2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('revokeSystemPermission_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(revokeSystemPermission_result)
revokeSystemPermission_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
)


class revokeTablePermission_args(object):
    """
    Attributes:
     - sharedSecret
     - user
     - table
     - perm

    """


    def __init__(self, sharedSecret=None, user=None, table=None, perm=None,):
        self.sharedSecret = sharedSecret
        self.user = user
        self.table = table
        self.perm = perm

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.user = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.table = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.perm = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('revokeTablePermission_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.user is not None:
            oprot.writeFieldBegin('user', TType.STRING, 2)
            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRING, 3)
            oprot.writeString(self.table.encode('utf-8') if sys.version_info[0] == 2 else self.table)
            oprot.writeFieldEnd()
        if self.perm is not None:
            oprot.writeFieldBegin('perm', TType.I32, 4)
            oprot.writeI32(self.perm)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(revokeTablePermission_args)
revokeTablePermission_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'table', 'UTF8', None, ),  # 3
    (4, TType.I32, 'perm', None, None, ),  # 4
)


class revokeTablePermission_result(object):
    """
    Attributes:
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = TableNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('revokeTablePermission_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(revokeTablePermission_result)
revokeTablePermission_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [TableNotFoundException, None], None, ),  # 3
)


class grantNamespacePermission_args(object):
    """
    Attributes:
     - sharedSecret
     - user
     - namespaceName
     - perm

    """


    def __init__(self, sharedSecret=None, user=None, namespaceName=None, perm=None,):
        self.sharedSecret = sharedSecret
        self.user = user
        self.namespaceName = namespaceName
        self.perm = perm

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.user = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.namespaceName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.perm = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('grantNamespacePermission_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.user is not None:
            oprot.writeFieldBegin('user', TType.STRING, 2)
            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
            oprot.writeFieldEnd()
        if self.namespaceName is not None:
            oprot.writeFieldBegin('namespaceName', TType.STRING, 3)
            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
            oprot.writeFieldEnd()
        if self.perm is not None:
            oprot.writeFieldBegin('perm', TType.I32, 4)
            oprot.writeI32(self.perm)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(grantNamespacePermission_args)
grantNamespacePermission_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 3
    (4, TType.I32, 'perm', None, None, ),  # 4
)


class grantNamespacePermission_result(object):
    """
    Attributes:
     - ouch1
     - ouch2

    """


    def __init__(self, ouch1=None, ouch2=None,):
        self.ouch1 = ouch1
        self.ouch2 = ouch2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('grantNamespacePermission_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(grantNamespacePermission_result)
grantNamespacePermission_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
)


class hasNamespacePermission_args(object):
    """
    Attributes:
     - sharedSecret
     - user
     - namespaceName
     - perm

    """


    def __init__(self, sharedSecret=None, user=None, namespaceName=None, perm=None,):
        self.sharedSecret = sharedSecret
        self.user = user
        self.namespaceName = namespaceName
        self.perm = perm

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.user = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.namespaceName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.perm = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('hasNamespacePermission_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.user is not None:
            oprot.writeFieldBegin('user', TType.STRING, 2)
            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
            oprot.writeFieldEnd()
        if self.namespaceName is not None:
            oprot.writeFieldBegin('namespaceName', TType.STRING, 3)
            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
            oprot.writeFieldEnd()
        if self.perm is not None:
            oprot.writeFieldBegin('perm', TType.I32, 4)
            oprot.writeI32(self.perm)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(hasNamespacePermission_args)
hasNamespacePermission_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 3
    (4, TType.I32, 'perm', None, None, ),  # 4
)


class hasNamespacePermission_result(object):
    """
    Attributes:
     - success
     - ouch1
     - ouch2

    """


    def __init__(self, success=None, ouch1=None, ouch2=None,):
        self.success = success
        self.ouch1 = ouch1
        self.ouch2 = ouch2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('hasNamespacePermission_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(hasNamespacePermission_result)
hasNamespacePermission_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
)


class revokeNamespacePermission_args(object):
    """
    Attributes:
     - sharedSecret
     - user
     - namespaceName
     - perm

    """


    def __init__(self, sharedSecret=None, user=None, namespaceName=None, perm=None,):
        self.sharedSecret = sharedSecret
        self.user = user
        self.namespaceName = namespaceName
        self.perm = perm

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.user = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.namespaceName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.perm = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('revokeNamespacePermission_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.user is not None:
            oprot.writeFieldBegin('user', TType.STRING, 2)
            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
            oprot.writeFieldEnd()
        if self.namespaceName is not None:
            oprot.writeFieldBegin('namespaceName', TType.STRING, 3)
            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
            oprot.writeFieldEnd()
        if self.perm is not None:
            oprot.writeFieldBegin('perm', TType.I32, 4)
            oprot.writeI32(self.perm)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(revokeNamespacePermission_args)
revokeNamespacePermission_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 3
    (4, TType.I32, 'perm', None, None, ),  # 4
)


class revokeNamespacePermission_result(object):
    """
    Attributes:
     - ouch1
     - ouch2

    """


    def __init__(self, ouch1=None, ouch2=None,):
        self.ouch1 = ouch1
        self.ouch2 = ouch2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('revokeNamespacePermission_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(revokeNamespacePermission_result)
revokeNamespacePermission_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
)


class createBatchScanner_args(object):
    """
    Attributes:
     - sharedSecret
     - tableName
     - options

    """


    def __init__(self, sharedSecret=None, tableName=None, options=None,):
        self.sharedSecret = sharedSecret
        self.tableName = tableName
        self.options = options

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.options = BatchScanOptions()
                    self.options.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createBatchScanner_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.options is not None:
            oprot.writeFieldBegin('options', TType.STRUCT, 3)
            self.options.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createBatchScanner_args)
createBatchScanner_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'options', [BatchScanOptions, None], None, ),  # 3
)


class createBatchScanner_result(object):
    """
    Attributes:
     - success
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
        self.success = success
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = TableNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createBatchScanner_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createBatchScanner_result)
createBatchScanner_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [TableNotFoundException, None], None, ),  # 3
)


class createScanner_args(object):
    """
    Attributes:
     - sharedSecret
     - tableName
     - options

    """


    def __init__(self, sharedSecret=None, tableName=None, options=None,):
        self.sharedSecret = sharedSecret
        self.tableName = tableName
        self.options = options

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.options = ScanOptions()
                    self.options.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createScanner_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.options is not None:
            oprot.writeFieldBegin('options', TType.STRUCT, 3)
            self.options.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createScanner_args)
createScanner_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'options', [ScanOptions, None], None, ),  # 3
)


class createScanner_result(object):
    """
    Attributes:
     - success
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
        self.success = success
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = TableNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createScanner_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createScanner_result)
createScanner_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [TableNotFoundException, None], None, ),  # 3
)


class hasNext_args(object):
    """
    Attributes:
     - scanner

    """


    def __init__(self, scanner=None,):
        self.scanner = scanner

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.scanner = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('hasNext_args')
        if self.scanner is not None:
            oprot.writeFieldBegin('scanner', TType.STRING, 1)
            oprot.writeString(self.scanner.encode('utf-8') if sys.version_info[0] == 2 else self.scanner)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(hasNext_args)
hasNext_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'scanner', 'UTF8', None, ),  # 1
)


class hasNext_result(object):
    """
    Attributes:
     - success
     - ouch1

    """


    def __init__(self, success=None, ouch1=None,):
        self.success = success
        self.ouch1 = ouch1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = UnknownScanner.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('hasNext_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(hasNext_result)
hasNext_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch1', [UnknownScanner, None], None, ),  # 1
)


class nextEntry_args(object):
    """
    Attributes:
     - scanner

    """


    def __init__(self, scanner=None,):
        self.scanner = scanner

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.scanner = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('nextEntry_args')
        if self.scanner is not None:
            oprot.writeFieldBegin('scanner', TType.STRING, 1)
            oprot.writeString(self.scanner.encode('utf-8') if sys.version_info[0] == 2 else self.scanner)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(nextEntry_args)
nextEntry_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'scanner', 'UTF8', None, ),  # 1
)


class nextEntry_result(object):
    """
    Attributes:
     - success
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
        self.success = success
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = KeyValueAndPeek()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = NoMoreEntriesException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = UnknownScanner.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('nextEntry_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(nextEntry_result)
nextEntry_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [KeyValueAndPeek, None], None, ),  # 0
    (1, TType.STRUCT, 'ouch1', [NoMoreEntriesException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [UnknownScanner, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [AccumuloSecurityException, None], None, ),  # 3
)


class nextK_args(object):
    """
    Attributes:
     - scanner
     - k

    """


    def __init__(self, scanner=None, k=None,):
        self.scanner = scanner
        self.k = k

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.scanner = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.k = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('nextK_args')
        if self.scanner is not None:
            oprot.writeFieldBegin('scanner', TType.STRING, 1)
            oprot.writeString(self.scanner.encode('utf-8') if sys.version_info[0] == 2 else self.scanner)
            oprot.writeFieldEnd()
        if self.k is not None:
            oprot.writeFieldBegin('k', TType.I32, 2)
            oprot.writeI32(self.k)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(nextK_args)
nextK_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'scanner', 'UTF8', None, ),  # 1
    (2, TType.I32, 'k', None, None, ),  # 2
)


class nextK_result(object):
    """
    Attributes:
     - success
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
        self.success = success
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ScanResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = NoMoreEntriesException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = UnknownScanner.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('nextK_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(nextK_result)
nextK_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ScanResult, None], None, ),  # 0
    (1, TType.STRUCT, 'ouch1', [NoMoreEntriesException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [UnknownScanner, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [AccumuloSecurityException, None], None, ),  # 3
)


class closeScanner_args(object):
    """
    Attributes:
     - scanner

    """


    def __init__(self, scanner=None,):
        self.scanner = scanner

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.scanner = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('closeScanner_args')
        if self.scanner is not None:
            oprot.writeFieldBegin('scanner', TType.STRING, 1)
            oprot.writeString(self.scanner.encode('utf-8') if sys.version_info[0] == 2 else self.scanner)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(closeScanner_args)
closeScanner_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'scanner', 'UTF8', None, ),  # 1
)


class closeScanner_result(object):
    """
    Attributes:
     - ouch1

    """


    def __init__(self, ouch1=None,):
        self.ouch1 = ouch1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = UnknownScanner.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('closeScanner_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(closeScanner_result)
closeScanner_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [UnknownScanner, None], None, ),  # 1
)


class updateAndFlush_args(object):
    """
    Attributes:
     - sharedSecret
     - tableName
     - cells

    """


    def __init__(self, sharedSecret=None, tableName=None, cells=None,):
        self.sharedSecret = sharedSecret
        self.tableName = tableName
        self.cells = cells

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.cells = {}
                    (_ktype382, _vtype383, _size381) = iprot.readMapBegin()
                    for _i385 in range(_size381):
                        _key386 = iprot.readBinary()
                        _val387 = []
                        (_etype391, _size388) = iprot.readListBegin()
                        for _i392 in range(_size388):
                            _elem393 = ColumnUpdate()
                            _elem393.read(iprot)
                            _val387.append(_elem393)
                        iprot.readListEnd()
                        self.cells[_key386] = _val387
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateAndFlush_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.cells is not None:
            oprot.writeFieldBegin('cells', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.cells))
            for kiter394, viter395 in self.cells.items():
                oprot.writeBinary(kiter394)
                oprot.writeListBegin(TType.STRUCT, len(viter395))
                for iter396 in viter395:
                    iter396.write(oprot)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateAndFlush_args)
updateAndFlush_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
    (3, TType.MAP, 'cells', (TType.STRING, 'BINARY', TType.LIST, (TType.STRUCT, [ColumnUpdate, None], False), False), None, ),  # 3
)


class updateAndFlush_result(object):
    """
    Attributes:
     - outch1
     - ouch2
     - ouch3
     - ouch4

    """


    def __init__(self, outch1=None, ouch2=None, ouch3=None, ouch4=None,):
        self.outch1 = outch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3
        self.ouch4 = ouch4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.outch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = TableNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ouch4 = MutationsRejectedException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateAndFlush_result')
        if self.outch1 is not None:
            oprot.writeFieldBegin('outch1', TType.STRUCT, 1)
            self.outch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch4 is not None:
            oprot.writeFieldBegin('ouch4', TType.STRUCT, 4)
            self.ouch4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateAndFlush_result)
updateAndFlush_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'outch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [TableNotFoundException, None], None, ),  # 3
    (4, TType.STRUCT, 'ouch4', [MutationsRejectedException, None], None, ),  # 4
)


class createWriter_args(object):
    """
    Attributes:
     - sharedSecret
     - tableName
     - opts

    """


    def __init__(self, sharedSecret=None, tableName=None, opts=None,):
        self.sharedSecret = sharedSecret
        self.tableName = tableName
        self.opts = opts

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.opts = WriterOptions()
                    self.opts.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createWriter_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.opts is not None:
            oprot.writeFieldBegin('opts', TType.STRUCT, 3)
            self.opts.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createWriter_args)
createWriter_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'opts', [WriterOptions, None], None, ),  # 3
)


class createWriter_result(object):
    """
    Attributes:
     - success
     - outch1
     - ouch2
     - ouch3

    """


    def __init__(self, success=None, outch1=None, ouch2=None, ouch3=None,):
        self.success = success
        self.outch1 = outch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.outch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = TableNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createWriter_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.outch1 is not None:
            oprot.writeFieldBegin('outch1', TType.STRUCT, 1)
            self.outch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createWriter_result)
createWriter_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'outch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [TableNotFoundException, None], None, ),  # 3
)


class update_args(object):
    """
    Attributes:
     - writer
     - cells

    """


    def __init__(self, writer=None, cells=None,):
        self.writer = writer
        self.cells = cells

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.writer = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.cells = {}
                    (_ktype398, _vtype399, _size397) = iprot.readMapBegin()
                    for _i401 in range(_size397):
                        _key402 = iprot.readBinary()
                        _val403 = []
                        (_etype407, _size404) = iprot.readListBegin()
                        for _i408 in range(_size404):
                            _elem409 = ColumnUpdate()
                            _elem409.read(iprot)
                            _val403.append(_elem409)
                        iprot.readListEnd()
                        self.cells[_key402] = _val403
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_args')
        if self.writer is not None:
            oprot.writeFieldBegin('writer', TType.STRING, 1)
            oprot.writeString(self.writer.encode('utf-8') if sys.version_info[0] == 2 else self.writer)
            oprot.writeFieldEnd()
        if self.cells is not None:
            oprot.writeFieldBegin('cells', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.cells))
            for kiter410, viter411 in self.cells.items():
                oprot.writeBinary(kiter410)
                oprot.writeListBegin(TType.STRUCT, len(viter411))
                for iter412 in viter411:
                    iter412.write(oprot)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_args)
update_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'writer', 'UTF8', None, ),  # 1
    (2, TType.MAP, 'cells', (TType.STRING, 'BINARY', TType.LIST, (TType.STRUCT, [ColumnUpdate, None], False), False), None, ),  # 2
)


class flush_args(object):
    """
    Attributes:
     - writer

    """


    def __init__(self, writer=None,):
        self.writer = writer

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.writer = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('flush_args')
        if self.writer is not None:
            oprot.writeFieldBegin('writer', TType.STRING, 1)
            oprot.writeString(self.writer.encode('utf-8') if sys.version_info[0] == 2 else self.writer)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(flush_args)
flush_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'writer', 'UTF8', None, ),  # 1
)


class flush_result(object):
    """
    Attributes:
     - ouch1
     - ouch2

    """


    def __init__(self, ouch1=None, ouch2=None,):
        self.ouch1 = ouch1
        self.ouch2 = ouch2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = UnknownWriter.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = MutationsRejectedException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('flush_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(flush_result)
flush_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [UnknownWriter, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [MutationsRejectedException, None], None, ),  # 2
)


class closeWriter_args(object):
    """
    Attributes:
     - writer

    """


    def __init__(self, writer=None,):
        self.writer = writer

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.writer = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('closeWriter_args')
        if self.writer is not None:
            oprot.writeFieldBegin('writer', TType.STRING, 1)
            oprot.writeString(self.writer.encode('utf-8') if sys.version_info[0] == 2 else self.writer)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(closeWriter_args)
closeWriter_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'writer', 'UTF8', None, ),  # 1
)


class closeWriter_result(object):
    """
    Attributes:
     - ouch1
     - ouch2

    """


    def __init__(self, ouch1=None, ouch2=None,):
        self.ouch1 = ouch1
        self.ouch2 = ouch2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = UnknownWriter.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = MutationsRejectedException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('closeWriter_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(closeWriter_result)
closeWriter_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [UnknownWriter, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [MutationsRejectedException, None], None, ),  # 2
)


class updateRowConditionally_args(object):
    """
    Attributes:
     - sharedSecret
     - tableName
     - row
     - updates

    """


    def __init__(self, sharedSecret=None, tableName=None, row=None, updates=None,):
        self.sharedSecret = sharedSecret
        self.tableName = tableName
        self.row = row
        self.updates = updates

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.row = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.updates = ConditionalUpdates()
                    self.updates.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateRowConditionally_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.row is not None:
            oprot.writeFieldBegin('row', TType.STRING, 3)
            oprot.writeBinary(self.row)
            oprot.writeFieldEnd()
        if self.updates is not None:
            oprot.writeFieldBegin('updates', TType.STRUCT, 4)
            self.updates.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateRowConditionally_args)
updateRowConditionally_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'row', 'BINARY', None, ),  # 3
    (4, TType.STRUCT, 'updates', [ConditionalUpdates, None], None, ),  # 4
)


class updateRowConditionally_result(object):
    """
    Attributes:
     - success
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
        self.success = success
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = TableNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateRowConditionally_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateRowConditionally_result)
updateRowConditionally_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [TableNotFoundException, None], None, ),  # 3
)


class createConditionalWriter_args(object):
    """
    Attributes:
     - sharedSecret
     - tableName
     - options

    """


    def __init__(self, sharedSecret=None, tableName=None, options=None,):
        self.sharedSecret = sharedSecret
        self.tableName = tableName
        self.options = options

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.options = ConditionalWriterOptions()
                    self.options.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createConditionalWriter_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.options is not None:
            oprot.writeFieldBegin('options', TType.STRUCT, 3)
            self.options.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createConditionalWriter_args)
createConditionalWriter_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'options', [ConditionalWriterOptions, None], None, ),  # 3
)


class createConditionalWriter_result(object):
    """
    Attributes:
     - success
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
        self.success = success
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = TableNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createConditionalWriter_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createConditionalWriter_result)
createConditionalWriter_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [TableNotFoundException, None], None, ),  # 3
)


class updateRowsConditionally_args(object):
    """
    Attributes:
     - conditionalWriter
     - updates

    """


    def __init__(self, conditionalWriter=None, updates=None,):
        self.conditionalWriter = conditionalWriter
        self.updates = updates

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.conditionalWriter = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.updates = {}
                    (_ktype414, _vtype415, _size413) = iprot.readMapBegin()
                    for _i417 in range(_size413):
                        _key418 = iprot.readBinary()
                        _val419 = ConditionalUpdates()
                        _val419.read(iprot)
                        self.updates[_key418] = _val419
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateRowsConditionally_args')
        if self.conditionalWriter is not None:
            oprot.writeFieldBegin('conditionalWriter', TType.STRING, 1)
            oprot.writeString(self.conditionalWriter.encode('utf-8') if sys.version_info[0] == 2 else self.conditionalWriter)
            oprot.writeFieldEnd()
        if self.updates is not None:
            oprot.writeFieldBegin('updates', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.updates))
            for kiter420, viter421 in self.updates.items():
                oprot.writeBinary(kiter420)
                viter421.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateRowsConditionally_args)
updateRowsConditionally_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'conditionalWriter', 'UTF8', None, ),  # 1
    (2, TType.MAP, 'updates', (TType.STRING, 'BINARY', TType.STRUCT, [ConditionalUpdates, None], False), None, ),  # 2
)


class updateRowsConditionally_result(object):
    """
    Attributes:
     - success
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
        self.success = success
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype423, _vtype424, _size422) = iprot.readMapBegin()
                    for _i426 in range(_size422):
                        _key427 = iprot.readBinary()
                        _val428 = iprot.readI32()
                        self.success[_key427] = _val428
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = UnknownWriter.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateRowsConditionally_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.I32, len(self.success))
            for kiter429, viter430 in self.success.items():
                oprot.writeBinary(kiter429)
                oprot.writeI32(viter430)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateRowsConditionally_result)
updateRowsConditionally_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'BINARY', TType.I32, None, False), None, ),  # 0
    (1, TType.STRUCT, 'ouch1', [UnknownWriter, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [AccumuloSecurityException, None], None, ),  # 3
)


class closeConditionalWriter_args(object):
    """
    Attributes:
     - conditionalWriter

    """


    def __init__(self, conditionalWriter=None,):
        self.conditionalWriter = conditionalWriter

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.conditionalWriter = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('closeConditionalWriter_args')
        if self.conditionalWriter is not None:
            oprot.writeFieldBegin('conditionalWriter', TType.STRING, 1)
            oprot.writeString(self.conditionalWriter.encode('utf-8') if sys.version_info[0] == 2 else self.conditionalWriter)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(closeConditionalWriter_args)
closeConditionalWriter_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'conditionalWriter', 'UTF8', None, ),  # 1
)


class closeConditionalWriter_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('closeConditionalWriter_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(closeConditionalWriter_result)
closeConditionalWriter_result.thrift_spec = (
)


class getRowRange_args(object):
    """
    Attributes:
     - row

    """


    def __init__(self, row=None,):
        self.row = row

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.row = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getRowRange_args')
        if self.row is not None:
            oprot.writeFieldBegin('row', TType.STRING, 1)
            oprot.writeBinary(self.row)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getRowRange_args)
getRowRange_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'row', 'BINARY', None, ),  # 1
)


class getRowRange_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Range()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getRowRange_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getRowRange_result)
getRowRange_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Range, None], None, ),  # 0
)


class getFollowing_args(object):
    """
    Attributes:
     - key
     - part

    """


    def __init__(self, key=None, part=None,):
        self.key = key
        self.part = part

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.key = Key()
                    self.key.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.part = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getFollowing_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRUCT, 1)
            self.key.write(oprot)
            oprot.writeFieldEnd()
        if self.part is not None:
            oprot.writeFieldBegin('part', TType.I32, 2)
            oprot.writeI32(self.part)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getFollowing_args)
getFollowing_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'key', [Key, None], None, ),  # 1
    (2, TType.I32, 'part', None, None, ),  # 2
)


class getFollowing_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Key()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getFollowing_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getFollowing_result)
getFollowing_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Key, None], None, ),  # 0
)


class systemNamespace_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('systemNamespace_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(systemNamespace_args)
systemNamespace_args.thrift_spec = (
)


class systemNamespace_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('systemNamespace_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(systemNamespace_result)
systemNamespace_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class defaultNamespace_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('defaultNamespace_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(defaultNamespace_args)
defaultNamespace_args.thrift_spec = (
)


class defaultNamespace_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('defaultNamespace_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(defaultNamespace_result)
defaultNamespace_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class listNamespaces_args(object):
    """
    Attributes:
     - sharedSecret

    """


    def __init__(self, sharedSecret=None,):
        self.sharedSecret = sharedSecret

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('listNamespaces_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(listNamespaces_args)
listNamespaces_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
)


class listNamespaces_result(object):
    """
    Attributes:
     - success
     - ouch1
     - ouch2

    """


    def __init__(self, success=None, ouch1=None, ouch2=None,):
        self.success = success
        self.ouch1 = ouch1
        self.ouch2 = ouch2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype434, _size431) = iprot.readListBegin()
                    for _i435 in range(_size431):
                        _elem436 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem436)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('listNamespaces_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter437 in self.success:
                oprot.writeString(iter437.encode('utf-8') if sys.version_info[0] == 2 else iter437)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(listNamespaces_result)
listNamespaces_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
)


class namespaceExists_args(object):
    """
    Attributes:
     - sharedSecret
     - namespaceName

    """


    def __init__(self, sharedSecret=None, namespaceName=None,):
        self.sharedSecret = sharedSecret
        self.namespaceName = namespaceName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.namespaceName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('namespaceExists_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.namespaceName is not None:
            oprot.writeFieldBegin('namespaceName', TType.STRING, 2)
            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(namespaceExists_args)
namespaceExists_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 2
)


class namespaceExists_result(object):
    """
    Attributes:
     - success
     - ouch1
     - ouch2

    """


    def __init__(self, success=None, ouch1=None, ouch2=None,):
        self.success = success
        self.ouch1 = ouch1
        self.ouch2 = ouch2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('namespaceExists_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(namespaceExists_result)
namespaceExists_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
)


class createNamespace_args(object):
    """
    Attributes:
     - sharedSecret
     - namespaceName

    """


    def __init__(self, sharedSecret=None, namespaceName=None,):
        self.sharedSecret = sharedSecret
        self.namespaceName = namespaceName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.namespaceName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createNamespace_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.namespaceName is not None:
            oprot.writeFieldBegin('namespaceName', TType.STRING, 2)
            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createNamespace_args)
createNamespace_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 2
)


class createNamespace_result(object):
    """
    Attributes:
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = NamespaceExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createNamespace_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createNamespace_result)
createNamespace_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [NamespaceExistsException, None], None, ),  # 3
)


class deleteNamespace_args(object):
    """
    Attributes:
     - sharedSecret
     - namespaceName

    """


    def __init__(self, sharedSecret=None, namespaceName=None,):
        self.sharedSecret = sharedSecret
        self.namespaceName = namespaceName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.namespaceName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deleteNamespace_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.namespaceName is not None:
            oprot.writeFieldBegin('namespaceName', TType.STRING, 2)
            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deleteNamespace_args)
deleteNamespace_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 2
)


class deleteNamespace_result(object):
    """
    Attributes:
     - ouch1
     - ouch2
     - ouch3
     - ouch4

    """


    def __init__(self, ouch1=None, ouch2=None, ouch3=None, ouch4=None,):
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3
        self.ouch4 = ouch4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = NamespaceNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ouch4 = NamespaceNotEmptyException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deleteNamespace_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch4 is not None:
            oprot.writeFieldBegin('ouch4', TType.STRUCT, 4)
            self.ouch4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deleteNamespace_result)
deleteNamespace_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [NamespaceNotFoundException, None], None, ),  # 3
    (4, TType.STRUCT, 'ouch4', [NamespaceNotEmptyException, None], None, ),  # 4
)


class renameNamespace_args(object):
    """
    Attributes:
     - sharedSecret
     - oldNamespaceName
     - newNamespaceName

    """


    def __init__(self, sharedSecret=None, oldNamespaceName=None, newNamespaceName=None,):
        self.sharedSecret = sharedSecret
        self.oldNamespaceName = oldNamespaceName
        self.newNamespaceName = newNamespaceName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.oldNamespaceName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.newNamespaceName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('renameNamespace_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.oldNamespaceName is not None:
            oprot.writeFieldBegin('oldNamespaceName', TType.STRING, 2)
            oprot.writeString(self.oldNamespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.oldNamespaceName)
            oprot.writeFieldEnd()
        if self.newNamespaceName is not None:
            oprot.writeFieldBegin('newNamespaceName', TType.STRING, 3)
            oprot.writeString(self.newNamespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.newNamespaceName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(renameNamespace_args)
renameNamespace_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'oldNamespaceName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'newNamespaceName', 'UTF8', None, ),  # 3
)


class renameNamespace_result(object):
    """
    Attributes:
     - ouch1
     - ouch2
     - ouch3
     - ouch4

    """


    def __init__(self, ouch1=None, ouch2=None, ouch3=None, ouch4=None,):
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3
        self.ouch4 = ouch4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = NamespaceNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ouch4 = NamespaceExistsException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('renameNamespace_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch4 is not None:
            oprot.writeFieldBegin('ouch4', TType.STRUCT, 4)
            self.ouch4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(renameNamespace_result)
renameNamespace_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [NamespaceNotFoundException, None], None, ),  # 3
    (4, TType.STRUCT, 'ouch4', [NamespaceExistsException, None], None, ),  # 4
)


class setNamespaceProperty_args(object):
    """
    Attributes:
     - sharedSecret
     - namespaceName
     - property
     - value

    """


    def __init__(self, sharedSecret=None, namespaceName=None, property=None, value=None,):
        self.sharedSecret = sharedSecret
        self.namespaceName = namespaceName
        self.property = property
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.namespaceName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.property = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setNamespaceProperty_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.namespaceName is not None:
            oprot.writeFieldBegin('namespaceName', TType.STRING, 2)
            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
            oprot.writeFieldEnd()
        if self.property is not None:
            oprot.writeFieldBegin('property', TType.STRING, 3)
            oprot.writeString(self.property.encode('utf-8') if sys.version_info[0] == 2 else self.property)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 4)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setNamespaceProperty_args)
setNamespaceProperty_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'property', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'value', 'UTF8', None, ),  # 4
)


class setNamespaceProperty_result(object):
    """
    Attributes:
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = NamespaceNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('setNamespaceProperty_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(setNamespaceProperty_result)
setNamespaceProperty_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [NamespaceNotFoundException, None], None, ),  # 3
)


class removeNamespaceProperty_args(object):
    """
    Attributes:
     - sharedSecret
     - namespaceName
     - property

    """


    def __init__(self, sharedSecret=None, namespaceName=None, property=None,):
        self.sharedSecret = sharedSecret
        self.namespaceName = namespaceName
        self.property = property

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.namespaceName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.property = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeNamespaceProperty_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.namespaceName is not None:
            oprot.writeFieldBegin('namespaceName', TType.STRING, 2)
            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
            oprot.writeFieldEnd()
        if self.property is not None:
            oprot.writeFieldBegin('property', TType.STRING, 3)
            oprot.writeString(self.property.encode('utf-8') if sys.version_info[0] == 2 else self.property)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeNamespaceProperty_args)
removeNamespaceProperty_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'property', 'UTF8', None, ),  # 3
)


class removeNamespaceProperty_result(object):
    """
    Attributes:
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = NamespaceNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeNamespaceProperty_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeNamespaceProperty_result)
removeNamespaceProperty_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [NamespaceNotFoundException, None], None, ),  # 3
)


class getNamespaceProperties_args(object):
    """
    Attributes:
     - sharedSecret
     - namespaceName

    """


    def __init__(self, sharedSecret=None, namespaceName=None,):
        self.sharedSecret = sharedSecret
        self.namespaceName = namespaceName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.namespaceName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getNamespaceProperties_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.namespaceName is not None:
            oprot.writeFieldBegin('namespaceName', TType.STRING, 2)
            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getNamespaceProperties_args)
getNamespaceProperties_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 2
)


class getNamespaceProperties_result(object):
    """
    Attributes:
     - success
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
        self.success = success
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype439, _vtype440, _size438) = iprot.readMapBegin()
                    for _i442 in range(_size438):
                        _key443 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val444 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key443] = _val444
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = NamespaceNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getNamespaceProperties_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter445, viter446 in self.success.items():
                oprot.writeString(kiter445.encode('utf-8') if sys.version_info[0] == 2 else kiter445)
                oprot.writeString(viter446.encode('utf-8') if sys.version_info[0] == 2 else viter446)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getNamespaceProperties_result)
getNamespaceProperties_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [NamespaceNotFoundException, None], None, ),  # 3
)


class namespaceIdMap_args(object):
    """
    Attributes:
     - sharedSecret

    """


    def __init__(self, sharedSecret=None,):
        self.sharedSecret = sharedSecret

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('namespaceIdMap_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(namespaceIdMap_args)
namespaceIdMap_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
)


class namespaceIdMap_result(object):
    """
    Attributes:
     - success
     - ouch1
     - ouch2

    """


    def __init__(self, success=None, ouch1=None, ouch2=None,):
        self.success = success
        self.ouch1 = ouch1
        self.ouch2 = ouch2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype448, _vtype449, _size447) = iprot.readMapBegin()
                    for _i451 in range(_size447):
                        _key452 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val453 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key452] = _val453
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('namespaceIdMap_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter454, viter455 in self.success.items():
                oprot.writeString(kiter454.encode('utf-8') if sys.version_info[0] == 2 else kiter454)
                oprot.writeString(viter455.encode('utf-8') if sys.version_info[0] == 2 else viter455)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(namespaceIdMap_result)
namespaceIdMap_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
)


class attachNamespaceIterator_args(object):
    """
    Attributes:
     - sharedSecret
     - namespaceName
     - setting
     - scopes

    """


    def __init__(self, sharedSecret=None, namespaceName=None, setting=None, scopes=None,):
        self.sharedSecret = sharedSecret
        self.namespaceName = namespaceName
        self.setting = setting
        self.scopes = scopes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.namespaceName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.setting = IteratorSetting()
                    self.setting.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.SET:
                    self.scopes = set()
                    (_etype459, _size456) = iprot.readSetBegin()
                    for _i460 in range(_size456):
                        _elem461 = iprot.readI32()
                        self.scopes.add(_elem461)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('attachNamespaceIterator_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.namespaceName is not None:
            oprot.writeFieldBegin('namespaceName', TType.STRING, 2)
            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
            oprot.writeFieldEnd()
        if self.setting is not None:
            oprot.writeFieldBegin('setting', TType.STRUCT, 3)
            self.setting.write(oprot)
            oprot.writeFieldEnd()
        if self.scopes is not None:
            oprot.writeFieldBegin('scopes', TType.SET, 4)
            oprot.writeSetBegin(TType.I32, len(self.scopes))
            for iter462 in self.scopes:
                oprot.writeI32(iter462)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(attachNamespaceIterator_args)
attachNamespaceIterator_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'setting', [IteratorSetting, None], None, ),  # 3
    (4, TType.SET, 'scopes', (TType.I32, None, False), None, ),  # 4
)


class attachNamespaceIterator_result(object):
    """
    Attributes:
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = NamespaceNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('attachNamespaceIterator_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(attachNamespaceIterator_result)
attachNamespaceIterator_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [NamespaceNotFoundException, None], None, ),  # 3
)


class removeNamespaceIterator_args(object):
    """
    Attributes:
     - sharedSecret
     - namespaceName
     - name
     - scopes

    """


    def __init__(self, sharedSecret=None, namespaceName=None, name=None, scopes=None,):
        self.sharedSecret = sharedSecret
        self.namespaceName = namespaceName
        self.name = name
        self.scopes = scopes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.namespaceName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.SET:
                    self.scopes = set()
                    (_etype466, _size463) = iprot.readSetBegin()
                    for _i467 in range(_size463):
                        _elem468 = iprot.readI32()
                        self.scopes.add(_elem468)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeNamespaceIterator_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.namespaceName is not None:
            oprot.writeFieldBegin('namespaceName', TType.STRING, 2)
            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 3)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.scopes is not None:
            oprot.writeFieldBegin('scopes', TType.SET, 4)
            oprot.writeSetBegin(TType.I32, len(self.scopes))
            for iter469 in self.scopes:
                oprot.writeI32(iter469)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeNamespaceIterator_args)
removeNamespaceIterator_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'name', 'UTF8', None, ),  # 3
    (4, TType.SET, 'scopes', (TType.I32, None, False), None, ),  # 4
)


class removeNamespaceIterator_result(object):
    """
    Attributes:
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = NamespaceNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeNamespaceIterator_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeNamespaceIterator_result)
removeNamespaceIterator_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [NamespaceNotFoundException, None], None, ),  # 3
)


class getNamespaceIteratorSetting_args(object):
    """
    Attributes:
     - sharedSecret
     - namespaceName
     - name
     - scope

    """


    def __init__(self, sharedSecret=None, namespaceName=None, name=None, scope=None,):
        self.sharedSecret = sharedSecret
        self.namespaceName = namespaceName
        self.name = name
        self.scope = scope

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.namespaceName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.scope = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getNamespaceIteratorSetting_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.namespaceName is not None:
            oprot.writeFieldBegin('namespaceName', TType.STRING, 2)
            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 3)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.scope is not None:
            oprot.writeFieldBegin('scope', TType.I32, 4)
            oprot.writeI32(self.scope)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getNamespaceIteratorSetting_args)
getNamespaceIteratorSetting_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'name', 'UTF8', None, ),  # 3
    (4, TType.I32, 'scope', None, None, ),  # 4
)


class getNamespaceIteratorSetting_result(object):
    """
    Attributes:
     - success
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
        self.success = success
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = IteratorSetting()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = NamespaceNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getNamespaceIteratorSetting_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getNamespaceIteratorSetting_result)
getNamespaceIteratorSetting_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [IteratorSetting, None], None, ),  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [NamespaceNotFoundException, None], None, ),  # 3
)


class listNamespaceIterators_args(object):
    """
    Attributes:
     - sharedSecret
     - namespaceName

    """


    def __init__(self, sharedSecret=None, namespaceName=None,):
        self.sharedSecret = sharedSecret
        self.namespaceName = namespaceName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.namespaceName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('listNamespaceIterators_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.namespaceName is not None:
            oprot.writeFieldBegin('namespaceName', TType.STRING, 2)
            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(listNamespaceIterators_args)
listNamespaceIterators_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 2
)


class listNamespaceIterators_result(object):
    """
    Attributes:
     - success
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
        self.success = success
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype471, _vtype472, _size470) = iprot.readMapBegin()
                    for _i474 in range(_size470):
                        _key475 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val476 = set()
                        (_etype480, _size477) = iprot.readSetBegin()
                        for _i481 in range(_size477):
                            _elem482 = iprot.readI32()
                            _val476.add(_elem482)
                        iprot.readSetEnd()
                        self.success[_key475] = _val476
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = NamespaceNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('listNamespaceIterators_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.SET, len(self.success))
            for kiter483, viter484 in self.success.items():
                oprot.writeString(kiter483.encode('utf-8') if sys.version_info[0] == 2 else kiter483)
                oprot.writeSetBegin(TType.I32, len(viter484))
                for iter485 in viter484:
                    oprot.writeI32(iter485)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(listNamespaceIterators_result)
listNamespaceIterators_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.SET, (TType.I32, None, False), False), None, ),  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [NamespaceNotFoundException, None], None, ),  # 3
)


class checkNamespaceIteratorConflicts_args(object):
    """
    Attributes:
     - sharedSecret
     - namespaceName
     - setting
     - scopes

    """


    def __init__(self, sharedSecret=None, namespaceName=None, setting=None, scopes=None,):
        self.sharedSecret = sharedSecret
        self.namespaceName = namespaceName
        self.setting = setting
        self.scopes = scopes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.namespaceName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.setting = IteratorSetting()
                    self.setting.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.SET:
                    self.scopes = set()
                    (_etype489, _size486) = iprot.readSetBegin()
                    for _i490 in range(_size486):
                        _elem491 = iprot.readI32()
                        self.scopes.add(_elem491)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('checkNamespaceIteratorConflicts_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.namespaceName is not None:
            oprot.writeFieldBegin('namespaceName', TType.STRING, 2)
            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
            oprot.writeFieldEnd()
        if self.setting is not None:
            oprot.writeFieldBegin('setting', TType.STRUCT, 3)
            self.setting.write(oprot)
            oprot.writeFieldEnd()
        if self.scopes is not None:
            oprot.writeFieldBegin('scopes', TType.SET, 4)
            oprot.writeSetBegin(TType.I32, len(self.scopes))
            for iter492 in self.scopes:
                oprot.writeI32(iter492)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(checkNamespaceIteratorConflicts_args)
checkNamespaceIteratorConflicts_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'setting', [IteratorSetting, None], None, ),  # 3
    (4, TType.SET, 'scopes', (TType.I32, None, False), None, ),  # 4
)


class checkNamespaceIteratorConflicts_result(object):
    """
    Attributes:
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = NamespaceNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('checkNamespaceIteratorConflicts_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(checkNamespaceIteratorConflicts_result)
checkNamespaceIteratorConflicts_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [NamespaceNotFoundException, None], None, ),  # 3
)


class addNamespaceConstraint_args(object):
    """
    Attributes:
     - sharedSecret
     - namespaceName
     - constraintClassName

    """


    def __init__(self, sharedSecret=None, namespaceName=None, constraintClassName=None,):
        self.sharedSecret = sharedSecret
        self.namespaceName = namespaceName
        self.constraintClassName = constraintClassName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.namespaceName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.constraintClassName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('addNamespaceConstraint_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.namespaceName is not None:
            oprot.writeFieldBegin('namespaceName', TType.STRING, 2)
            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
            oprot.writeFieldEnd()
        if self.constraintClassName is not None:
            oprot.writeFieldBegin('constraintClassName', TType.STRING, 3)
            oprot.writeString(self.constraintClassName.encode('utf-8') if sys.version_info[0] == 2 else self.constraintClassName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(addNamespaceConstraint_args)
addNamespaceConstraint_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'constraintClassName', 'UTF8', None, ),  # 3
)


class addNamespaceConstraint_result(object):
    """
    Attributes:
     - success
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
        self.success = success
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = NamespaceNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('addNamespaceConstraint_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(addNamespaceConstraint_result)
addNamespaceConstraint_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [NamespaceNotFoundException, None], None, ),  # 3
)


class removeNamespaceConstraint_args(object):
    """
    Attributes:
     - sharedSecret
     - namespaceName
     - id

    """


    def __init__(self, sharedSecret=None, namespaceName=None, id=None,):
        self.sharedSecret = sharedSecret
        self.namespaceName = namespaceName
        self.id = id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.namespaceName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeNamespaceConstraint_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.namespaceName is not None:
            oprot.writeFieldBegin('namespaceName', TType.STRING, 2)
            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
            oprot.writeFieldEnd()
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I32, 3)
            oprot.writeI32(self.id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeNamespaceConstraint_args)
removeNamespaceConstraint_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 2
    (3, TType.I32, 'id', None, None, ),  # 3
)


class removeNamespaceConstraint_result(object):
    """
    Attributes:
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = NamespaceNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeNamespaceConstraint_result')
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeNamespaceConstraint_result)
removeNamespaceConstraint_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [NamespaceNotFoundException, None], None, ),  # 3
)


class listNamespaceConstraints_args(object):
    """
    Attributes:
     - sharedSecret
     - namespaceName

    """


    def __init__(self, sharedSecret=None, namespaceName=None,):
        self.sharedSecret = sharedSecret
        self.namespaceName = namespaceName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.namespaceName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('listNamespaceConstraints_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.namespaceName is not None:
            oprot.writeFieldBegin('namespaceName', TType.STRING, 2)
            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(listNamespaceConstraints_args)
listNamespaceConstraints_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 2
)


class listNamespaceConstraints_result(object):
    """
    Attributes:
     - success
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
        self.success = success
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype494, _vtype495, _size493) = iprot.readMapBegin()
                    for _i497 in range(_size493):
                        _key498 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val499 = iprot.readI32()
                        self.success[_key498] = _val499
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = NamespaceNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('listNamespaceConstraints_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.I32, len(self.success))
            for kiter500, viter501 in self.success.items():
                oprot.writeString(kiter500.encode('utf-8') if sys.version_info[0] == 2 else kiter500)
                oprot.writeI32(viter501)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(listNamespaceConstraints_result)
listNamespaceConstraints_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.I32, None, False), None, ),  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [NamespaceNotFoundException, None], None, ),  # 3
)


class testNamespaceClassLoad_args(object):
    """
    Attributes:
     - sharedSecret
     - namespaceName
     - className
     - asTypeName

    """


    def __init__(self, sharedSecret=None, namespaceName=None, className=None, asTypeName=None,):
        self.sharedSecret = sharedSecret
        self.namespaceName = namespaceName
        self.className = className
        self.asTypeName = asTypeName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sharedSecret = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.namespaceName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.className = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.asTypeName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testNamespaceClassLoad_args')
        if self.sharedSecret is not None:
            oprot.writeFieldBegin('sharedSecret', TType.STRING, 1)
            oprot.writeString(self.sharedSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sharedSecret)
            oprot.writeFieldEnd()
        if self.namespaceName is not None:
            oprot.writeFieldBegin('namespaceName', TType.STRING, 2)
            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
            oprot.writeFieldEnd()
        if self.className is not None:
            oprot.writeFieldBegin('className', TType.STRING, 3)
            oprot.writeString(self.className.encode('utf-8') if sys.version_info[0] == 2 else self.className)
            oprot.writeFieldEnd()
        if self.asTypeName is not None:
            oprot.writeFieldBegin('asTypeName', TType.STRING, 4)
            oprot.writeString(self.asTypeName.encode('utf-8') if sys.version_info[0] == 2 else self.asTypeName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testNamespaceClassLoad_args)
testNamespaceClassLoad_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sharedSecret', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'className', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'asTypeName', 'UTF8', None, ),  # 4
)


class testNamespaceClassLoad_result(object):
    """
    Attributes:
     - success
     - ouch1
     - ouch2
     - ouch3

    """


    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
        self.success = success
        self.ouch1 = ouch1
        self.ouch2 = ouch2
        self.ouch3 = ouch3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch1 = AccumuloException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ouch2 = AccumuloSecurityException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ouch3 = NamespaceNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testNamespaceClassLoad_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.ouch1 is not None:
            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
            self.ouch1.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch2 is not None:
            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
            self.ouch2.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch3 is not None:
            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
            self.ouch3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testNamespaceClassLoad_result)
testNamespaceClassLoad_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch1', [AccumuloException, None], None, ),  # 1
    (2, TType.STRUCT, 'ouch2', [AccumuloSecurityException, None], None, ),  # 2
    (3, TType.STRUCT, 'ouch3', [NamespaceNotFoundException, None], None, ),  # 3
)
fix_spec(all_structs)
del all_structs
